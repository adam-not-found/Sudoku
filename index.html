<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="public/icon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sudoku</title>
    
    <!-- PWA Manifest and Theme -->
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#0f172a" />
    
    <!-- PWA Meta Tags for iOS & Android -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Sudoku" />
    <link rel="apple-touch-icon" href="public/icon.svg" />

    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add Babel to transpile JSX/TSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
          "react/": "https://esm.sh/react@18.2.0/",
          "react": "https://esm.sh/react@18.2.0",
          "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
          "react-dom/": "https://esm.sh/react-dom@18.2.0/"
        }
      }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Inter', sans-serif;
        background-color: #eef1f5;
        transition: background-color 0.5s ease-in-out;
      }
      body.dark {
        background-color: #0f172a; /* slate-900 */
      }
      
      @keyframes shake {
        10%, 90% { transform: translate3d(-1px, 0, 0); }
        20%, 80% { transform: translate3d(2px, 0, 0); }
        30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
        40%, 60% { transform: translate3d(4px, 0, 0); }
      }
      .animate-shake {
          animation: shake 0.25s cubic-bezier(.36,.07,.19,.97) both;
      }
      
      @keyframes pop {
        0% { transform: scale(1); }
        50% { transform: scale(1.3); }
        100% { transform: scale(1); }
      }
      .animate-pop {
        animation: pop 0.2s ease-in-out;
      }

      @keyframes rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      .animate-rotate {
        animation: rotate 0.5s ease-in-out;
      }

      @keyframes hint-pop-glow {
        0% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7); }
        100% { box-shadow: 0 0 10px 25px rgba(251, 191, 36, 0); }
      }
      .animate-hint-pop {
        animation: hint-pop-glow 0.4s ease-out;
      }

      @keyframes hint-refill-glow {
        0% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.5); }
        100% { box-shadow: 0 0 8px 15px rgba(251, 191, 36, 0); }
      }
      .animate-hint-refill {
        animation: hint-refill-glow 0.3s ease-out;
      }

      @keyframes hint-cell-glow {
        0% { box-shadow: 0 0 0px 0px rgba(251, 191, 36, 0.7); }
        50% { box-shadow: 0 0 12px 6px rgba(251, 191, 36, 0.7); }
        100% { box-shadow: 0 0 0px 0px rgba(251, 191, 36, 0); }
      }
      .animate-hint-cell {
        animation: hint-cell-glow 0.8s ease-out;
      }

      @keyframes fill-up {
        from { clip-path: inset(100% 0 0 0); }
        to { clip-path: inset(0% 0 0 0); }
      }
      .animate-fill-up {
        /* The duration is set dynamically via inline styles */
        animation-name: fill-up;
        animation-timing-function: linear;
        animation-fill-mode: forwards;
      }

      .text-shadow-blue-glow {
        text-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel" data-type="module" data-presets="react,typescript">
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/

import React from 'react';
import ReactDOM from 'react-dom/client';

// From services/sudokuGenerator.ts
const shuffle = (array) => {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
};

const isSafe = (grid, row, col, num) => {
  for (let x = 0; x < 9; x++) {
    if (grid[row][x] === num) return false;
  }
  for (let x = 0; x < 9; x++) {
    if (grid[x][col] === num) return false;
  }
  const startRow = row - (row % 3);
  const startCol = col - (col % 3);
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      if (grid[i + startRow][j + startCol] === num) return false;
    }
  }
  return true;
};

const solveGrid = (grid) => {
  for (let row = 0; row < 9; row++) {
    for (let col = 0; col < 9; col++) {
      if (grid[row][col] === 0) {
        const numbers = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
        for (const num of numbers) {
          if (isSafe(grid, row, col, num)) {
            grid[row][col] = num;
            if (solveGrid(grid)) return true;
            grid[row][col] = 0;
          }
        }
        return false;
      }
    }
  }
  return true;
};

const countSolutions = (grid) => {
  let count = 0;
  function solve() {
    if (count > 1) return;

    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        if (grid[r][c] === 0) {
          for (let num = 1; num <= 9; num++) {
            if (isSafe(grid, r, c, num)) {
              grid[r][c] = num;
              solve();
              grid[r][c] = 0; // Backtrack
            }
          }
          return; // Finished with this empty cell
        }
      }
    }
    count++;
  }
  solve();
  return count;
};

const REMOVAL_COUNT = {
  easy: 40,
  medium: 48,
  hard: 54,
  professional: 58,
};

const DIFFICULTY_SCORES = {
  easy: { min: 1, max: 2 },
  medium: { min: 3, max: 4 },
  hard: { min: 5, max: 7 },
  professional: { min: 8, max: 99 },
};

const ratePuzzleDifficulty = (puzzle) => {
    let board = puzzle.map(row =>
      row.map(value => ({
        value,
        eliminatedNotes: new Set(),
      }))
    );

    let maxScore = 0;
    let stuck = false;

    while (!stuck) {
        let moveMade = false;
        
        const techniques = [
            { func: findNakedSingle, score: 1 },
            { func: findHiddenSingle, score: 2 },
            { func: findNakedPair, score: 3 },
            { func: findHiddenPair, score: 4 },
            { func: findNakedTriple, score: 5 },
            { func: findHiddenTriple, score: 6 },
            { func: findIntersectionRemoval, score: 7 },
            { func: findXWing, score: 8 },
            { func: findSwordfish, score: 9 },
        ];
        
        for (const technique of techniques) {
            const hint = technique.func(board, null);
            if (hint) {
                maxScore = Math.max(maxScore, technique.score);
                
                if (hint.solve) {
                    const { row, col, num } = hint.solve;
                    board[row][col].value = num;
                    board[row][col].eliminatedNotes.clear();
                } else if (hint.eliminations.length > 0) {
                    hint.eliminations.forEach(({ row, col, num }) => {
                        board[row][col].eliminatedNotes.add(num);
                    });
                }
                
                moveMade = true;
                break; // Restart scan from easiest technique
            }
        }

        if (!moveMade) {
            stuck = true;
        }
    }

    const isSolved = board.every(row => row.every(cell => cell.value !== 0));
    return isSolved ? maxScore : 99; // 99 for puzzles needing harder techniques
};

const generateSudoku = (difficulty = 'medium') => {
  let puzzle, solution;
  let attempts = 0;
  const targetDifficulty = DIFFICULTY_SCORES[difficulty];

  while(attempts < 100) { // Safety break after 100 tries
    attempts++;
    
    solution = Array(9).fill(0).map(() => Array(9).fill(0));
    solveGrid(solution);
    
    const candidatePuzzle = solution.map(row => [...row]);
    const cells = [];
    for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { cells.push({ r, c }); } }
    shuffle(cells);

    let removedCount = 0;
    const cellsToRemove = REMOVAL_COUNT[difficulty] ?? 48;

    for (const cell of cells) {
      if (removedCount >= cellsToRemove) { break; }
      
      const { r, c } = cell;
      const backup = candidatePuzzle[r][c];
      candidatePuzzle[r][c] = 0;
      
      const puzzleCopy = candidatePuzzle.map(row => [...row]);
      const numSolutions = countSolutions(puzzleCopy);
      
      if (numSolutions !== 1) {
        candidatePuzzle[r][c] = backup;
      } else {
        removedCount++;
      }
    }

    const puzzleScore = ratePuzzleDifficulty(candidatePuzzle);

    if (puzzleScore >= targetDifficulty.min && puzzleScore <= targetDifficulty.max) {
      puzzle = candidatePuzzle;
      break; 
    }
  }

  // Fallback if a suitable puzzle isn't found
  if (!puzzle) {
    console.warn(`Could not generate a '${difficulty}' puzzle with guaranteed difficulty. Using fallback.`);
    solution = Array(9).fill(0).map(() => Array(9).fill(0));
    solveGrid(solution);
    puzzle = solution.map(row => [...row]);
    
    const cells = [];
    for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { cells.push({ r, c }); } }
    shuffle(cells);

    let removedCount = 0;
    const cellsToRemove = REMOVAL_COUNT[difficulty] ?? 48;

    for (const cell of cells) {
        if (removedCount >= cellsToRemove) break;
        const { r, c } = cell;
        const backup = puzzle[r][c];
        puzzle[r][c] = 0;
        const puzzleCopy = puzzle.map(row => [...row]);
        if (countSolutions(puzzleCopy) !== 1) {
            puzzle[r][c] = backup;
        } else {
            removedCount++;
        }
    }
  }
  
  return { puzzle, solution };
};


// From components/icons.tsx
const UndoIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2.5}>
    <g transform="translate(2, 2)">
      <path strokeLinecap="round" strokeLinejoin="round" d="M15 15v-3.375A4.125 4.125 0 0010.875 7.5H4.5" />
      <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 11.25L4.5 7.5l3.75-3.75" />
    </g>
  </svg>
);

const RedoIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2.5}>
    <g transform="translate(2, 2)">
      <path strokeLinecap="round" strokeLinejoin="round" d="M5 15v-3.375A4.125 4.125 0 019.125 7.5H15.5" />
      <path strokeLinecap="round" strokeLinejoin="round" d="M11.75 11.25L15.5 7.5l-3.75-3.75" />
    </g>
  </svg>
);

const EraseIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
  </svg>
);

const NotesIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" />
  </svg>
);

const bulbPath = "M12 2.25c-4.142 0-7.5 3.358-7.5 7.5 0 2.434 1.157 4.583 2.963 5.992v3.008a.75.75 0 00.75.75h7.584a.75.75 0 00.75-.75v-3.008c1.806-1.409 2.963-3.558 2.963-5.992 0-4.142-3.358-7.5-7.5-7.5zM9.75 21a.75.75 0 000 1.5h4.5a.75.75 0 000-1.5H9.75z";

const HintIconFull = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="currentColor" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={0.5}>
    <path strokeLinecap="round" strokeLinejoin="round" d={bulbPath} />
  </svg>
);

const HintIconEmpty = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
    <path strokeLinecap="round" strokeLinejoin="round" d={bulbPath} />
  </svg>
);

const SettingsIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
    <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
  </svg>
);

const StatsIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2.5}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M7 16V8m4 8V4m4 12V6" />
    </svg>
);


// From components/Cell.tsx
const { useState, useEffect, useRef } = React;

function usePrevious(value) {
  const ref = useRef(undefined);
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

const Cell = ({ data, isSelected, isPeer, isHighlighted, isCorrect, onClick, isDarkMode, isNotesMode, isAutoNotesEnabled, highlightedNumber, isHintPrimary, isHintSecondary, hintEffect, rowIndex, colIndex, className = '' }) => {
  const { value, isInitial, isWrong, userNotes, autoNotes, eliminatedNotes } = data;

  const [isAnimating, setIsAnimating] = useState(false);
  const [isPopAnimating, setIsPopAnimating] = useState(false);
  const prevValue = usePrevious(value);

  useEffect(() => {
    if (isWrong && value !== 0 && value !== prevValue) {
      setIsAnimating(true);
    }
    if (isCorrect && !isInitial && value !== 0 && value !== prevValue) {
      setIsPopAnimating(true);
    }
  }, [value, isWrong, isCorrect, isInitial, prevValue]);
  
  const handleAnimationEnd = () => {
    setIsAnimating(false);
    setIsPopAnimating(false);
  };

  const getCellClasses = () => {
    const classParts = [
      'aspect-square flex items-center justify-center text-2xl sm:text-3xl font-sans transition-all duration-200',
      'cursor-pointer',
    ];

    let backgroundClass = '';
    let textClass = '';
    let fontClass = '';
    let hoverClass = '';

    const determineTextColor = () => {
      if (isInitial) {
        fontClass = 'font-semibold';
        return isDarkMode ? 'text-slate-100' : 'text-slate-800';
      }
      if (isWrong) {
        return isDarkMode ? 'text-red-400' : 'text-red-500';
      }
      if (isCorrect) {
        fontClass = 'font-semibold';
      }
      return isDarkMode ? 'text-sky-400' : 'text-sky-600';
    };

    textClass = determineTextColor();
    
    if (isSelected) {
      backgroundClass = isDarkMode ? 'bg-sky-800 z-10' : 'bg-sky-200 z-10';
      hoverClass = '';
    } else {
      if (isDarkMode) {
        hoverClass = isInitial ? 'hover:bg-slate-700/80' : 'hover:bg-sky-900/50';
        if (isHintPrimary) backgroundClass = 'bg-amber-400/60';
        else if (isHintSecondary) backgroundClass = 'bg-amber-400/30';
        else if (isHighlighted && value !== 0) backgroundClass = 'bg-blue-800/60';
        else if (isPeer) backgroundClass = 'bg-slate-700';
        else backgroundClass = 'bg-slate-800';
      } else {
        hoverClass = isInitial ? 'hover:bg-slate-200/80' : 'hover:bg-sky-100';
        if (isHintPrimary) backgroundClass = 'bg-amber-300/80';
        else if (isHintSecondary) backgroundClass = 'bg-amber-300/50';
        else if (isHighlighted && value !== 0) backgroundClass = 'bg-blue-100';
        else if (isPeer) backgroundClass = 'bg-slate-100';
        else backgroundClass = 'bg-white';
      }
    }
    
    classParts.push(backgroundClass, textClass, fontClass, hoverClass);
    return classParts.filter(Boolean).join(' ');
  };

  const isHintGlowTarget = hintEffect?.type === 'cell-glow' && hintEffect.cell.row === rowIndex && hintEffect.cell.col === colIndex;
  const shakeAnimationClass = isAnimating ? 'animate-shake' : '';
  const hintAnimationClass = isHintGlowTarget ? 'animate-hint-cell' : '';
  const cellClasses = `${getCellClasses()} ${shakeAnimationClass} ${hintAnimationClass} ${className}`;
  const popAnimationClass = isPopAnimating ? 'animate-pop inline-block' : '';
  
  const hasUserOrAutoNotes = userNotes.size > 0 || autoNotes.size > 0;
  const hasEliminationNotes = eliminatedNotes.size > 0;
  const shouldShowNotesGrid = value === 0 && (hasUserOrAutoNotes || hasEliminationNotes);
  const shouldDimValue = isNotesMode && !isInitial && !isCorrect;

  return (
    <div className={cellClasses} onClick={onClick} onAnimationEnd={handleAnimationEnd}>
      {value !== 0 ? (
        <span className={`${popAnimationClass} transition-opacity duration-300 ${shouldDimValue ? 'opacity-70' : ''}`}>{value}</span>
      ) : shouldShowNotesGrid ? (
        <div className={`grid grid-cols-3 grid-rows-3 w-full h-full p-px text-[10px] sm:text-xs leading-none text-transparent`}>
          {Array.from({ length: 9 }).map((_, i) => {
            const num = i + 1;
            const isUserNote = userNotes.has(num);
            const isAutoNote = autoNotes.has(num);
            const isEliminationNote = eliminatedNotes.has(num);
            const isNewlyEliminated = hintEffect?.type === 'note-pop' &&
                                    hintEffect.eliminations.some(e => e.row === rowIndex && e.col === colIndex && e.num === num);

            const isNoteVisible = isUserNote || isAutoNote || isEliminationNote;
            if (!isNoteVisible) return <div key={i} />;
            
            const isTheHighlightedNote = isHighlighted && highlightedNumber === num;
            
            let noteClass = '';
            let fontWeightClass = '';
            let textShadowClass = '';
            let noteAnimationClass = '';

            if (isEliminationNote) {
              noteClass = isDarkMode ? 'text-red-400' : 'text-red-500';
              fontWeightClass = 'font-semibold';
              if (isNewlyEliminated) {
                noteAnimationClass = 'animate-pop';
              }
            } else if (isTheHighlightedNote) {
              noteClass = isDarkMode 
                ? 'bg-sky-500/60 text-white rounded-sm' 
                : 'bg-sky-200 text-sky-800 rounded-sm';
              fontWeightClass = 'font-bold';
            } else {
              if (isDarkMode && (isHintPrimary || isHintSecondary)) {
                noteClass = 'text-slate-100';
              } else if (isAutoNotesEnabled) {
                if (isUserNote) {
                  noteClass = isDarkMode ? 'text-sky-300' : 'text-sky-500';
                } else {
                  noteClass = isDarkMode ? 'text-slate-300' : 'text-slate-400';
                }
              } else {
                noteClass = isDarkMode ? 'text-slate-200' : 'text-slate-500';
              }

              if (isNotesMode) {
                fontWeightClass = 'font-bold';
                if (isAutoNotesEnabled && isUserNote) {
                  textShadowClass = 'text-shadow-blue-glow';
                }
              } else {
                if (isUserNote || !isAutoNotesEnabled) {
                  fontWeightClass = 'font-medium';
                }
              }
            }
            
            return (
              <div key={i} className={`flex items-center justify-center transition-all duration-200 ${noteClass} ${fontWeightClass} ${textShadowClass} ${noteAnimationClass}`}>
                {num}
              </div>
            );
          })}
        </div>
      ) : (
        ''
      )}
    </div>
  );
};

// From components/SudokuBoard.tsx
const SudokuBoard = ({ board, solution, selectedCell, onCellClick, isNotesMode, isDarkMode, forceDarkMode, isAutoNotesEnabled, isHighlightNotesEnabled, highlightedNumber, activeHint, hintEffect }) => {
  const isDark = isDarkMode || forceDarkMode;
  const outerBorderBgColor = isDark ? 'bg-slate-600' : 'bg-slate-300';
  const thickInnerBorderColor = isDark ? 'bg-slate-500' : 'bg-slate-400';
  const thinInnerBorderColor = isDark ? 'bg-slate-700/65' : 'bg-slate-200';

  return (
    <div className={`relative transition-all duration-300 ease-in-out aspect-square w-full transform-gpu ${isNotesMode ? 'scale-[1.03]' : ''}`}>
      <div className={`absolute inset-0 rounded-2xl ${outerBorderBgColor}`}></div>
      <div className={`absolute inset-[6px] grid grid-cols-3 grid-rows-3 gap-[2px] ${thickInnerBorderColor} rounded-xl overflow-hidden`}>
        {Array.from({ length: 9 }).map((_, boxIndex) => {
          const boxRowStart = Math.floor(boxIndex / 3) * 3;
          const boxColStart = (boxIndex % 3) * 3;
          
          let boxCornerClass = '';
          if (boxIndex === 0) boxCornerClass = 'rounded-tl-xl';
          if (boxIndex === 2) boxCornerClass = 'rounded-tr-xl';
          if (boxIndex === 6) boxCornerClass = 'rounded-bl-xl';
          if (boxIndex === 8) boxCornerClass = 'rounded-br-xl';

          return (
            <div key={boxIndex} className={`grid grid-cols-3 grid-rows-3 gap-[1px] ${thinInnerBorderColor} ${boxCornerClass}`}>
              {Array.from({ length: 9 }).map((_, cellInBoxIndex) => {
                const cellRow = Math.floor(cellInBoxIndex / 3);
                const cellCol = cellInBoxIndex % 3;
                const rowIndex = boxRowStart + cellRow;
                const colIndex = boxColStart + cellCol;
                const cellData = board[rowIndex][colIndex];
                const isSelected = selectedCell?.row === rowIndex && selectedCell?.col === colIndex;
                const isPeer = selectedCell ? 
                  (selectedCell.row === rowIndex || selectedCell.col === colIndex || 
                  (Math.floor(selectedCell.row / 3) === Math.floor(rowIndex / 3) && Math.floor(selectedCell.col / 3) === Math.floor(colIndex / 3)))
                  : false;
                const isCorrect = !cellData.isInitial && cellData.value !== 0 && cellData.value === solution[rowIndex][colIndex];
                
                let isHighlighted = false;
                if (highlightedNumber !== null && !isSelected) {
                  const isHighlightedByValue = cellData.value === highlightedNumber;
                  const isHighlightedByNote =
                    isHighlightNotesEnabled &&
                    cellData.value === 0 &&
                    (cellData.userNotes.has(highlightedNumber) || cellData.autoNotes.has(highlightedNumber));
                  isHighlighted = isHighlightedByValue || isHighlightedByNote;
                }

                const isHintPrimary = !!activeHint?.primaryCells.some(c => c.row === rowIndex && c.col === colIndex);
                const isHintSecondary = !!activeHint?.secondaryCells.some(c => c.row === rowIndex && c.col === colIndex);
                
                let cellCornerClass = '';
                if (rowIndex === 0 && colIndex === 0) cellCornerClass = 'rounded-tl-sm';
                if (rowIndex === 0 && colIndex === 8) cellCornerClass = 'rounded-tr-sm';
                if (rowIndex === 8 && colIndex === 0) cellCornerClass = 'rounded-bl-sm';
                if (rowIndex === 8 && colIndex === 8) cellCornerClass = 'rounded-br-sm';

                return (
                  <Cell 
                    key={`${rowIndex}-${colIndex}`}
                    data={cellData}
                    isSelected={isSelected}
                    isPeer={isPeer && !isSelected}
                    isHighlighted={isHighlighted}
                    isCorrect={isCorrect}
                    onClick={() => onCellClick(rowIndex, colIndex)}
                    isDarkMode={isDark}
                    isNotesMode={isNotesMode}
                    className={cellCornerClass}
                    isAutoNotesEnabled={isAutoNotesEnabled}
                    highlightedNumber={highlightedNumber}
                    isHintPrimary={isHintPrimary}
                    isHintSecondary={isHintSecondary}
                    hintEffect={hintEffect}
                    rowIndex={rowIndex}
                    colIndex={colIndex}
                  />
                );
              })}
            </div>
          );
        })}
      </div>
    </div>
  );
};


// From components/NumberPad.tsx
const NumberPad = ({ onNumberClick, isNotesMode, isDarkMode }) => {
  const containerBgClass = isNotesMode
    ? (isDarkMode ? 'bg-slate-600' : 'bg-slate-700')
    : (isDarkMode ? 'bg-slate-700' : 'bg-slate-800');
  const buttonHoverFocusClass = isDarkMode
    ? 'hover:bg-slate-600/80 focus:bg-slate-600'
    : 'hover:bg-slate-700/80 focus:bg-slate-700';
  const baseButtonClasses = `
    transition-all duration-200 transform active:scale-90
    text-slate-200 ${buttonHoverFocusClass}
  `;

  return (
    <div className={`rounded-full p-1 flex justify-around items-center w-full transition-all duration-300 shadow-lg ${containerBgClass}`}>
      {Array.from({ length: 9 }).map((_, i) => {
        const num = i + 1;
        return (
          <button
            key={num}
            onClick={() => onNumberClick(num)}
            className={`
              w-12 h-12 sm:w-16 sm:h-16 
              flex items-center justify-center
              font-semibold text-3xl sm:text-4xl
              rounded-full 
              focus:outline-none 
              ${baseButtonClasses}
            `}
            aria-label={`Enter number ${num}`}
          >
            {num}
          </button>
        );
      })}
    </div>
  );
};

// From components/Controls.tsx
const Controls = ({ 
  isNotesMode, 
  onToggleNotesMode, 
  onUndo, 
  canUndo,
  onRedo,
  canRedo,
  onHint, 
  isHintOnCooldown,
  cooldownDuration,
  onDelete,
  isDarkMode,
  hintButtonEffect
}) => {
  const [popAnimation, setPopAnimation] = useState(false);
  const prevCooldown = useRef(isHintOnCooldown);
  const animationKey = useRef(0);

  useEffect(() => {
    if (prevCooldown.current && !isHintOnCooldown) {
      setPopAnimation(true);
    }
    prevCooldown.current = isHintOnCooldown;
  }, [isHintOnCooldown]);
  
  const handleHintClick = () => {
    if (isHintOnCooldown) return;
    animationKey.current += 1;
    onHint();
  };

  const baseButtonClasses = "w-12 h-12 flex items-center justify-center rounded-full transition-all duration-300 transform focus:outline-none active:scale-90 disabled:opacity-30 disabled:cursor-not-allowed disabled:bg-transparent";
  const containerClasses = isDarkMode ? 'bg-slate-700' : 'bg-slate-800';
  const iconButtonClasses = isDarkMode ? 'text-slate-300 hover:bg-slate-600/80' : 'text-slate-300 hover:bg-slate-700/80';
  const hintIconClasses = isDarkMode ? 'text-amber-400' : 'text-amber-300';
  const notesButtonDynamicClasses = isNotesMode 
    ? 'bg-blue-500 text-white shadow-[0_0_15px_rgba(59,130,246,0.7)]' 
    : iconButtonClasses;
  const hintHoverClass = isHintOnCooldown ? '' : (isDarkMode ? 'hover:bg-slate-600/80' : 'hover:bg-slate-700/80');
  const hintButtonAnimationClass = hintButtonEffect === 'shake' ? 'animate-shake' : '';
  const popAnimationClass = popAnimation ? 'animate-hint-refill' : '';
  
  return (
    <div className={`rounded-full p-2 flex justify-center items-center shadow-lg transition-colors duration-300 ${containerClasses}`}>
      <button 
        onClick={onUndo}
        disabled={!canUndo}
        className={`${baseButtonClasses} ${iconButtonClasses} ${canRedo ? 'mr-1' : 'mr-2'} `}
        aria-label="Undo last move"
      >
        <UndoIcon />
      </button>
      <div className={`transition-all duration-300 ease-in-out flex items-center justify-center ${canRedo ? 'w-12 opacity-100' : 'w-0 opacity-0'}`} style={{transitionProperty: 'width, opacity'}}>
        <button
            onClick={onRedo}
            disabled={!canRedo}
            className={`${baseButtonClasses} ${iconButtonClasses}`}
            aria-label="Redo last move"
        >
            <RedoIcon />
        </button>
      </div>
      <button 
        onClick={onDelete}
        className={`${baseButtonClasses} ${iconButtonClasses} ml-1`}
        aria-label="Delete number or notes"
      >
        <EraseIcon />
      </button>
      <button 
        onClick={onToggleNotesMode}
        className={`${baseButtonClasses} ${notesButtonDynamicClasses} ml-2`}
        aria-label={`Toggle notes mode, currently ${isNotesMode ? 'on' : 'off'}`}
      >
        <NotesIcon />
      </button>
      <button 
        onClick={handleHintClick}
        disabled={isHintOnCooldown}
        className={`${baseButtonClasses} ${hintIconClasses} ${hintHoverClass} ${hintButtonAnimationClass} ${popAnimationClass} ml-2`}
        onAnimationEnd={() => setPopAnimation(false)}
        aria-label={isHintOnCooldown ? "Hint is on cooldown" : "Get a hint"}
      >
        <div className="relative w-full h-full flex items-center justify-center">
          {isHintOnCooldown ? (
            <>
              <HintIconEmpty />
              <div
                key={animationKey.current}
                className="absolute w-full h-full animate-fill-up flex items-center justify-center"
                style={{ animationDuration: `${cooldownDuration}s` }}
              >
                <HintIconFull />
              </div>
            </>
          ) : (
            <HintIconFull />
          )}
        </div>
      </button>
    </div>
  );
};

// From components/Header.tsx
const Header = ({ isDarkMode, onOpenSettings, onOpenStats, onNewGame, elapsedTime, isTimerVisible }) => {
  const [showNewGameConfirm, setShowNewGameConfirm] = useState(false);
  const menuRef = useRef(null);
  const textColor = isDarkMode ? 'text-slate-100' : 'text-gray-800';
  const buttonColor = isDarkMode 
    ? 'text-slate-300 hover:bg-slate-700/80' 
    : 'text-slate-600 hover:bg-slate-200/80';
  const baseButtonClasses = `
    flex items-center justify-center rounded-full transition-colors duration-300 
    focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500
  `;

  useEffect(() => {
    const handleClickOutside = (event) => {
        if (menuRef.current && !menuRef.current.contains(event.target)) {
            setShowNewGameConfirm(false);
        }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
        document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const handleNewGameClick = () => {
    onNewGame();
    setShowNewGameConfirm(false);
  };

  const formatTime = (milliseconds) => {
    if (typeof milliseconds !== 'number' || milliseconds < 0) return '0:00';
    const totalSeconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  return (
    <header className="absolute top-2 left-0 right-0 w-full p-4 z-20">
      <div className="relative w-full flex items-center justify-between h-12">
        <div className="flex-1 flex justify-start">
          <div className="flex items-center gap-2">
            <button
              onClick={onOpenStats}
              className={`w-12 h-12 ${baseButtonClasses} ${buttonColor}`}
              aria-label="Open statistics"
            >
              <StatsIcon />
            </button>
            {isTimerVisible && (
              <div className={`px-3 py-1.5 rounded-full text-lg font-semibold transition-colors ${isDarkMode ? 'bg-slate-700/80 text-slate-300' : 'bg-slate-200/80 text-slate-600'}`}>
                  {formatTime(elapsedTime)}
              </div>
            )}
          </div>
        </div>
        <div className="flex-1 flex justify-center">
            <div className="relative" ref={menuRef}>
                <h1 
                    onClick={() => setShowNewGameConfirm(prev => !prev)}
                    className={`text-3xl font-bold tracking-tight ${textColor} cursor-pointer select-none transition-colors hover:text-sky-400`}
                    aria-haspopup="true"
                    aria-expanded={showNewGameConfirm}
                >
                    Sudoku
                </h1>
                <div className={`
                    absolute top-full left-1/2 -translate-x-1/2 mt-3
                    transform transition-all duration-200 ease-out
                    origin-top
                    ${showNewGameConfirm ? 'opacity-100 scale-100' : 'opacity-0 scale-95 pointer-events-none'}
                `}>
                    <button
                        onClick={handleNewGameClick}
                        className={`
                            whitespace-nowrap font-semibold py-2 px-5 rounded-full shadow-lg
                            ${isDarkMode ? 'bg-slate-700 text-slate-100 hover:bg-slate-600' : 'bg-white text-slate-700 hover:bg-slate-100'}
                            transition-all active:scale-95
                        `}
                    >
                        New Game
                    </button>
                </div>
            </div>
        </div>
        <div className="flex-1 flex justify-end">
            <div className="flex items-center gap-1">
                <button
                    onClick={onOpenSettings}
                    className={`w-12 h-12 ${baseButtonClasses} ${buttonColor}`}
                    aria-label="Open settings"
                >
                    <SettingsIcon />
                </button>
            </div>
        </div>
      </div>
    </header>
  );
};

// From components/VictoryScreen.tsx
const StatItem = ({ label, value }) => (
  <div className="flex flex-col items-center justify-center">
    <span className="text-sm font-medium text-slate-600 uppercase tracking-wider">{label}</span>
    <span className="text-3xl font-bold text-slate-900">{value}</span>
  </div>
);

const VictoryScreen = ({ message, moves, time, mistakes }) => {
  const [showContainer, setShowContainer] = useState(false);
  const [showTitle, setShowTitle] = useState(false);
  const [showStats, setShowStats] = useState(false);

  useEffect(() => {
    const containerTimer = setTimeout(() => setShowContainer(true), 100);
    const titleTimer = setTimeout(() => setShowTitle(true), 300);
    const statsTimer = setTimeout(() => setShowStats(true), 500);
    return () => {
      clearTimeout(containerTimer);
      clearTimeout(titleTimer);
      clearTimeout(statsTimer);
    };
  }, []);

  const getTitleSizeClass = () => {
    if (message.length > 35) return 'text-xl sm:text-2xl';
    if (message.length > 20) return 'text-2xl sm:text-3xl';
    return 'text-3xl';
  };

  return (
    <div className="absolute inset-0 z-[100] pointer-events-none">
      <div className="absolute inset-0 flex items-center justify-center">
        <div
          className={`
            w-auto min-w-[320px] max-w-sm flex flex-col items-center justify-center gap-6
            bg-sky-200/65 backdrop-blur p-8 rounded-2xl shadow-2xl
            transition-all duration-500 ease-in-out
            ${showContainer ? 'opacity-100 translate-y-0 scale-100' : 'opacity-0 -translate-y-4 scale-95'}
          `}
        >
          <h2
            className={`text-center font-bold text-slate-800 transition-all duration-500 ease-in-out ${getTitleSizeClass()} ${
              showTitle ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-4'
            }`}
          >
            {message}
          </h2>
          <div className={`
            flex justify-center items-center gap-x-8 sm:gap-x-12
            transition-all duration-500 ease-in-out
            ${showStats ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}
          `}>
            <StatItem label="Time" value={time} />
            <StatItem label="Moves" value={moves} />
            <StatItem label="Mistakes" value={mistakes} />
          </div>
        </div>
      </div>
    </div>
  );
};

// From components/SettingsPanel.tsx
const settingsPanelDifficulties = [
  { id: 'easy', label: 'Easy' },
  { id: 'medium', label: 'Medium' },
  { id: 'hard', label: 'Hard' },
  { id: 'professional', label: 'Pro' },
];

const SettingsPanel = ({ 
  isOpen, 
  onClose, 
  currentDifficulty, 
  isDarkMode, 
  onToggleDarkMode, 
  onFillBoard,
  isAutoNotesEnabled,
  onSetAutoNotes,
  isHighlightNotesEnabled,
  onSetHighlightNotes,
  isTimerVisible,
  onSetIsTimerVisible
}) => {
  const [selectedDifficulty, setSelectedDifficulty] = useState(currentDifficulty);

  useEffect(() => {
    if (isOpen) {
      setSelectedDifficulty(currentDifficulty);
    }
  }, [isOpen, currentDifficulty]);

  if (!isOpen) return null;

  const handleDone = () => onClose(selectedDifficulty);
  const modalBgClass = isDarkMode ? 'bg-slate-800/90 border-slate-600 backdrop-blur-sm' : 'bg-white/90 border-slate-200 backdrop-blur-sm';
  const modalTextClass = isDarkMode ? 'text-slate-100' : 'text-slate-800';
  const doneButtonClass = isDarkMode ? 'bg-sky-600 hover:bg-sky-500 text-white' : 'bg-sky-500 hover:bg-sky-600 text-white';
  const sectionBgClass = isDarkMode ? 'bg-slate-700/50' : 'bg-slate-100';
  const baseButtonClasses = 'w-full text-center font-semibold py-3 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2';
  const selectedClasses = isDarkMode 
    ? 'bg-sky-500 text-white shadow-md' 
    : 'bg-sky-600 text-white shadow-md';
  const unselectedClasses = isDarkMode 
    ? 'bg-slate-700 hover:bg-slate-600' 
    : 'bg-slate-200 hover:bg-slate-300';

  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/30" aria-modal="true" role="dialog">
      <div className={`
        w-full max-w-md m-4 p-6 rounded-2xl shadow-2xl border
        flex flex-col gap-6
        transform transition-all duration-300 ease-in-out
        ${isOpen ? 'opacity-100 scale-100' : 'opacity-0 scale-95'}
        ${modalBgClass} ${modalTextClass}
      `}>
        <h2 className="text-2xl font-bold text-center">Settings</h2>
        <div className="flex flex-col gap-2">
          <h3 className="text-lg font-semibold mb-2">Difficulty</h3>
          <div className="grid grid-cols-2 gap-3">
            {settingsPanelDifficulties.map(({ id, label }) => {
              const isSelected = selectedDifficulty === id;
              return (
                <button
                  key={id}
                  onClick={() => setSelectedDifficulty(id)}
                  className={`${baseButtonClasses} ${isSelected ? selectedClasses : unselectedClasses}`}
                  aria-pressed={isSelected}
                >
                  {label}
                </button>
              );
            })}
          </div>
        </div>
        <div className="flex flex-col gap-2">
          <h3 className="text-lg font-semibold mb-2">Gameplay</h3>
          <div className={`p-4 rounded-lg ${sectionBgClass} flex flex-col gap-4`}>
            <div className="flex justify-between items-center">
              <label htmlFor="auto-notes-toggle" className="font-medium pr-4">
                Auto Notes
                <p className={`text-xs font-normal ${isDarkMode ? 'text-slate-400' : 'text-slate-500'}`}>
                  Show all possible notes for empty cells.
                </p>
              </label>
              <button
                id="auto-notes-toggle"
                onClick={() => onSetAutoNotes(!isAutoNotesEnabled)}
                role="switch"
                aria-checked={isAutoNotesEnabled}
                className={`relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 ${isDarkMode ? 'focus:ring-offset-slate-800' : 'focus:ring-offset-white'} ${isAutoNotesEnabled ? 'bg-sky-500' : (isDarkMode ? 'bg-slate-600' : 'bg-gray-200')}`}
              >
                <span
                  aria-hidden="true"
                  className={`pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out ${isAutoNotesEnabled ? 'translate-x-5' : 'translate-x-0'}`}
                />
              </button>
            </div>
            <div className="flex justify-between items-center">
              <label htmlFor="highlight-notes-toggle" className="font-medium pr-4">
                Highlight Notes
                <p className={`text-xs font-normal ${isDarkMode ? 'text-slate-400' : 'text-slate-500'}`}>
                  Also highlight notes matching the selected number.
                </p>
              </label>
              <button
                id="highlight-notes-toggle"
                onClick={() => onSetHighlightNotes(!isHighlightNotesEnabled)}
                role="switch"
                aria-checked={isHighlightNotesEnabled}
                className={`relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 ${isDarkMode ? 'focus:ring-offset-slate-800' : 'focus:ring-offset-white'} ${isHighlightNotesEnabled ? 'bg-sky-500' : (isDarkMode ? 'bg-slate-600' : 'bg-gray-200')}`}
              >
                <span
                  aria-hidden="true"
                  className={`pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out ${isHighlightNotesEnabled ? 'translate-x-5' : 'translate-x-0'}`}
                />
              </button>
            </div>
            <div className="flex justify-between items-center">
              <label htmlFor="timer-toggle" className="font-medium pr-4">
                Show Timer
                <p className={`text-xs font-normal ${isDarkMode ? 'text-slate-400' : 'text-slate-500'}`}>
                  Display the game timer in the header.
                </p>
              </label>
              <button
                id="timer-toggle"
                onClick={() => onSetIsTimerVisible(!isTimerVisible)}
                role="switch"
                aria-checked={isTimerVisible}
                className={`relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 ${isDarkMode ? 'focus:ring-offset-slate-800' : 'focus:ring-offset-white'} ${isTimerVisible ? 'bg-sky-500' : (isDarkMode ? 'bg-slate-600' : 'bg-gray-200')}`}
              >
                <span
                  aria-hidden="true"
                  className={`pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out ${isTimerVisible ? 'translate-x-5' : 'translate-x-0'}`}
                />
              </button>
            </div>
          </div>
        </div>
        <div className="flex flex-col gap-2">
          <h3 className="text-lg font-semibold mb-2">Theme</h3>
          <div className="grid grid-cols-2 gap-3">
            {['Light', 'Dark'].map((theme) => {
              const isSelected = (theme === 'Light' && !isDarkMode) || (theme === 'Dark' && isDarkMode);
              return (
                <button
                  key={theme}
                  onClick={() => {
                    if ((theme === 'Light' && isDarkMode) || (theme === 'Dark' && !isDarkMode)) {
                      onToggleDarkMode();
                    }
                  }}
                  className={`${baseButtonClasses} ${isSelected ? selectedClasses : unselectedClasses}`}
                  aria-pressed={isSelected}
                >
                  {theme}
                </button>
              );
            })}
          </div>
        </div>
        <div className="flex justify-between items-center mt-2">
          <button 
            onClick={onFillBoard}
            className={`text-sm font-medium transition-colors ${isDarkMode ? 'text-slate-400 hover:text-slate-200' : 'text-slate-500 hover:text-slate-800'}`}
            aria-label="Fill board with solution"
          >
            I give up
          </button>
          <button
            onClick={handleDone}
            className={`font-bold py-2 px-6 rounded-lg shadow-md transition-colors ${doneButtonClass}`}
          >
            Done
          </button>
        </div>
      </div>
    </div>
  );
};

// From components/StatsPanel.tsx
const statsPanelDifficulties = [
  { id: 'easy', label: 'Easy' },
  { id: 'medium', label: 'Medium' },
  { id: 'hard', label: 'Hard' },
  { id: 'professional', label: 'Pro' },
];

const StatCard = ({ label, value, isDarkMode }) => (
  <div className={`flex flex-col items-center justify-center p-3 rounded-lg ${isDarkMode ? 'bg-slate-700' : 'bg-slate-100'}`}>
    <span className={`text-3xl font-bold ${isDarkMode ? 'text-slate-100' : 'text-slate-800'}`}>{value}</span>
    <span className={`text-xs font-medium uppercase tracking-wider ${isDarkMode ? 'text-slate-400' : 'text-slate-500'}`}>{label}</span>
  </div>
);

const formatStatsTime = (milliseconds) => {
    if (milliseconds === null || milliseconds <= 0) return '-:--';
    const totalSeconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
};

const StatsPanel = ({ isOpen, onClose, stats, isDarkMode }) => {
  const playedDifficulties = statsPanelDifficulties.filter(d => stats.byDifficulty[d.id].wins > 0);
  const [activeTab, setActiveTab] = useState(null);

  useEffect(() => {
    const currentlyPlayed = statsPanelDifficulties.filter(d => stats.byDifficulty[d.id].wins > 0);
    if (currentlyPlayed.length > 0) {
      if (!activeTab || !currentlyPlayed.some(d => d.id === activeTab)) {
        setActiveTab(currentlyPlayed[0].id);
      }
    } else {
      setActiveTab(null);
    }
  }, [stats, activeTab]);

  if (!isOpen) return null;
  
  const handleClose = () => onClose();
  const modalBgClass = isDarkMode ? 'bg-slate-800/90 border-slate-600 backdrop-blur-sm' : 'bg-white/90 border-slate-200 backdrop-blur-sm';
  const modalTextClass = isDarkMode ? 'text-slate-100' : 'text-slate-800';
  const doneButtonClass = isDarkMode ? 'bg-sky-600 hover:bg-sky-500 text-white' : 'bg-sky-500 hover:bg-sky-600 text-white';
  const tabButtonBase = 'text-center font-semibold py-2 px-4 rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 text-sm';
  const tabSelectedClasses = isDarkMode 
    ? 'bg-sky-500 text-white shadow-md' 
    : 'bg-sky-600 text-white shadow-md';
  const tabUnselectedClasses = isDarkMode 
    ? 'bg-slate-700 hover:bg-slate-600' 
    : 'bg-slate-200 hover:bg-slate-300';
  
  const winPercentage = stats.gamesPlayed > 0 ? Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0;
  const avgMoves = stats.gamesWon > 0 ? (stats.totalMoves / stats.gamesWon).toFixed(1) : '0.0';
  const avgMistakes = stats.gamesWon > 0 ? (stats.totalMistakes / stats.gamesWon).toFixed(1) : '0.0';

  const currentDifficultyStats = activeTab ? stats.byDifficulty[activeTab] : null;
  const averageTime = currentDifficultyStats && currentDifficultyStats.wins > 0 ? currentDifficultyStats.totalTime / currentDifficultyStats.wins : 0;

  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/30" aria-modal="true" role="dialog" onClick={handleClose}>
      <div 
        className={`
            w-full max-w-md m-4 p-6 rounded-2xl shadow-2xl border
            flex flex-col gap-6
            transform transition-all duration-300 ease-in-out
            ${isOpen ? 'opacity-100 scale-100' : 'opacity-0 scale-95'}
            ${modalBgClass} ${modalTextClass}
        `}
        onClick={(e) => e.stopPropagation()}
      >
        <h2 className="text-2xl font-bold text-center">Statistics</h2>
        <>
            <div className="grid grid-cols-4 gap-3 text-center">
                <StatCard label="Played" value={stats.gamesPlayed} isDarkMode={isDarkMode}/>
                <StatCard label="Win %" value={`${winPercentage}%`} isDarkMode={isDarkMode}/>
                <StatCard label="Avg. Moves" value={avgMoves} isDarkMode={isDarkMode}/>
                <StatCard label="Avg. Mistakes" value={avgMistakes} isDarkMode={isDarkMode}/>
            </div>
            {playedDifficulties.length > 0 && activeTab && currentDifficultyStats && (
              <div className="flex flex-col gap-3">
                  <div className="flex justify-center gap-2">
                      {playedDifficulties.map(({ id, label }) => (
                          <button 
                              key={id} 
                              onClick={() => setActiveTab(id)}
                              className={`${tabButtonBase} ${activeTab === id ? tabSelectedClasses : tabUnselectedClasses}`}
                              aria-pressed={activeTab === id}
                          >
                              {label}
                          </button>
                      ))}
                  </div>
                  <div className="grid grid-cols-3 gap-3 text-center">
                      <StatCard label="Wins" value={currentDifficultyStats.wins} isDarkMode={isDarkMode} />
                      <StatCard label="Best Time" value={formatStatsTime(currentDifficultyStats.bestTime)} isDarkMode={isDarkMode} />
                      <StatCard label="Avg. Time" value={formatStatsTime(averageTime)} isDarkMode={isDarkMode} />
                  </div>
              </div>
            )}
            <div className="flex justify-center items-center mt-2">
              <button
                onClick={handleClose}
                className={`font-bold py-2 px-6 rounded-lg shadow-md transition-colors ${doneButtonClass}`}
              >
                Done
              </button>
            </div>
        </>
      </div>
    </div>
  );
};

const calculateCandidates = (currentBoard, row, col) => {
    const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
    const gridValues = currentBoard.map(r => r.map(c => c.value));
    for (let i = 0; i < 9; i++) {
        if (gridValues[row][i] !== 0) candidates.delete(gridValues[row][i]);
        if (gridValues[i][col] !== 0) candidates.delete(gridValues[i][col]);
    }
    const boxStartRow = Math.floor(row / 3) * 3;
    const boxStartCol = Math.floor(col / 3) * 3;
    for (let i = boxStartRow; i < boxStartRow + 3; i++) {
        for (let j = boxStartCol; j < boxStartCol + 3; j++) {
            if (gridValues[i][j] !== 0) candidates.delete(gridValues[i][j]);
        }
    }
    return candidates;
};

// --- HINT LOGIC SERVICE ---
const getNotes = (board, row, col) => {
    const cell = board[row][col];
    if (cell.value !== 0) return new Set();
    const candidates = calculateCandidates(board, row, col);
    cell.eliminatedNotes.forEach(eliminated => candidates.delete(eliminated));
    return candidates;
};

const getUnitCells = (type, index) => {
    const cells = [];
    if (type === 'row') {
        for (let c = 0; c < 9; c++) cells.push({ row: index, col: c });
    } else if (type === 'col') {
        for (let r = 0; r < 9; r++) cells.push({ row: r, col: index });
    } else if (type === 'box') {
        const boxStartRow = Math.floor(index / 3) * 3;
        const boxStartCol = (index % 3) * 3;
        for (let r = boxStartRow; r < boxStartRow + 3; r++) {
            for (let c = boxStartCol; c < boxStartCol + 3; c++) {
                cells.push({ row: r, col: c });
            }
        }
    }
    return cells;
};

const findNakedSingle = (board, targetCell) => {
    const checkCell = (r, c) => {
        if (board[r][c].value === 0) {
            const notes = getNotes(board, r, c);
            if (notes.size === 1) {
                const num = notes.values().next().value;
                return {
                    type: 'Naked Single',
                    primaryCells: [{ row: r, col: c }],
                    secondaryCells: [],
                    eliminations: [],
                    solve: { row: r, col: c, num },
                };
            }
        }
        return null;
    }
    if (targetCell) return checkCell(targetCell.row, targetCell.col);

    for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
            const hint = checkCell(r, c);
            if (hint) return hint;
        }
    }
    return null;
};

const findHiddenSingle = (board, targetCell) => {
    const unitConfigs = [];
    if (targetCell) {
        const boxIndex = Math.floor(targetCell.row / 3) * 3 + Math.floor(targetCell.col / 3);
        unitConfigs.push({ type: 'row', index: targetCell.row, cells: getUnitCells('row', targetCell.row) });
        unitConfigs.push({ type: 'col', index: targetCell.col, cells: getUnitCells('col', targetCell.col) });
        unitConfigs.push({ type: 'box', index: boxIndex, cells: getUnitCells('box', boxIndex) });
    } else {
        for(let i=0; i<9; i++) {
            unitConfigs.push({ type: 'row', index: i, cells: getUnitCells('row', i) });
            unitConfigs.push({ type: 'col', index: i, cells: getUnitCells('col', i) });
            unitConfigs.push({ type: 'box', index: i, cells: getUnitCells('box', i) });
        }
    }

    for (const unit of unitConfigs) {
        const candidateMap = new Map();
        for (let num = 1; num <= 9; num++) { candidateMap.set(num, []); }

        for (const cell of unit.cells) {
            if (board[cell.row][cell.col].value === 0) {
                const notes = getNotes(board, cell.row, cell.col);
                notes.forEach(num => {
                    candidateMap.get(num).push(cell);
                });
            }
        }

        for (let num = 1; num <= 9; num++) {
            const possibleCells = candidateMap.get(num);
            if (possibleCells.length === 1) {
                const target = possibleCells[0];
                if (targetCell && (target.row !== targetCell.row || target.col !== targetCell.col)) {
                    continue;
                }
                const secondaryCells = unit.cells.filter(c => !(c.row === target.row && c.col === target.col));
                return {
                    type: 'Hidden Single',
                    primaryCells: [target],
                    secondaryCells: secondaryCells,
                    eliminations: [],
                    solve: { row: target.row, col: target.col, num },
                };
            }
        }
    }
    return null;
};

const findNakedPair = (board, targetCell) => {
    const units = [];
    if (targetCell) {
        const boxIndex = Math.floor(targetCell.row / 3) * 3 + Math.floor(targetCell.col / 3);
        units.push(getUnitCells('row', targetCell.row));
        units.push(getUnitCells('col', targetCell.col));
        units.push(getUnitCells('box', boxIndex));
    } else {
        for(let i=0; i<9; i++) {
            units.push(getUnitCells('row', i));
            units.push(getUnitCells('col', i));
            units.push(getUnitCells('box', i));
        }
    }

    for (const unit of units) {
        const cellsWithTwoNotes = unit.filter(cell => getNotes(board, cell.row, cell.col).size === 2);
        if (cellsWithTwoNotes.length < 2) continue;

        for (let i = 0; i < cellsWithTwoNotes.length; i++) {
            for (let j = i + 1; j < cellsWithTwoNotes.length; j++) {
                const cell1 = cellsWithTwoNotes[i];
                const cell2 = cellsWithTwoNotes[j];
                const notes1 = getNotes(board, cell1.row, cell1.col);
                const notes2 = getNotes(board, cell2.row, cell2.col);
                const notes1Arr = [...notes1].sort();
                const notes2Arr = [...notes2].sort();

                if (notes1Arr.length === 2 && notes1Arr[0] === notes2Arr[0] && notes1Arr[1] === notes2Arr[1]) {
                    const pairNums = notes1Arr;
                    const primaryCells = [cell1, cell2];
                    const eliminations = [];
                    const secondaryCells = [];

                    for (const unitCell of unit) {
                        if (primaryCells.some(pc => pc.row === unitCell.row && pc.col === unitCell.col)) continue;
                        
                        const unitCellNotes = getNotes(board, unitCell.row, unitCell.col);
                        let madeElimination = false;
                        if (unitCellNotes.has(pairNums[0])) {
                            eliminations.push({ row: unitCell.row, col: unitCell.col, num: pairNums[0] });
                            madeElimination = true;
                        }
                        if (unitCellNotes.has(pairNums[1])) {
                            eliminations.push({ row: unitCell.row, col: unitCell.col, num: pairNums[1] });
                            madeElimination = true;
                        }
                        if (madeElimination && !secondaryCells.some(sc => sc.row === unitCell.row && sc.col === unitCell.col)) {
                            secondaryCells.push(unitCell);
                        }
                    }

                    if (eliminations.length > 0) {
                        if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                        
                        return {
                            type: 'Naked Pair',
                            primaryCells,
                            secondaryCells,
                            eliminations,
                            solve: null,
                        };
                    }
                }
            }
        }
    }
    return null;
};

const findHiddenPair = (board, targetCell) => {
    const units = [];
    if (targetCell) {
        const boxIndex = Math.floor(targetCell.row / 3) * 3 + Math.floor(targetCell.col / 3);
        units.push(getUnitCells('row', targetCell.row));
        units.push(getUnitCells('col', targetCell.col));
        units.push(getUnitCells('box', boxIndex));
    } else {
        for(let i=0; i<9; i++) {
            units.push(getUnitCells('row', i));
            units.push(getUnitCells('col', i));
            units.push(getUnitCells('box', i));
        }
    }
    
    for (const unit of units) {
        const candidateMap = new Map();
        for (let num = 1; num <= 9; num++) { candidateMap.set(num, []); }

        for (const cell of unit) {
            if (board[cell.row][cell.col].value === 0) {
                getNotes(board, cell.row, cell.col).forEach(num => {
                    candidateMap.get(num).push(cell);
                });
            }
        }

        const numsInTwoCells = [];
        for (let num = 1; num <= 9; num++) {
            if (candidateMap.get(num).length === 2) {
                numsInTwoCells.push(num);
            }
        }

        if (numsInTwoCells.length < 2) continue;

        for (let i = 0; i < numsInTwoCells.length; i++) {
            for (let j = i + 1; j < numsInTwoCells.length; j++) {
                const num1 = numsInTwoCells[i];
                const num2 = numsInTwoCells[j];
                const cells1 = candidateMap.get(num1);
                const cells2 = candidateMap.get(num2);

                const cells1Ids = cells1.map(c => `${c.row}-${c.col}`).sort();
                const cells2Ids = cells2.map(c => `${c.row}-${c.col}`).sort();

                if (cells1Ids[0] === cells2Ids[0] && cells1Ids[1] === cells2Ids[1]) {
                    const primaryCells = cells1;
                    if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;

                    const allNotesInPair = new Set([...getNotes(board, primaryCells[0].row, primaryCells[0].col), ...getNotes(board, primaryCells[1].row, primaryCells[1].col)]);
                    allNotesInPair.delete(num1);
                    allNotesInPair.delete(num2);

                    const eliminations = [];
                    allNotesInPair.forEach(note => {
                        eliminations.push({ row: primaryCells[0].row, col: primaryCells[0].col, num: note });
                        eliminations.push({ row: primaryCells[1].row, col: primaryCells[1].col, num: note });
                    });
                    
                    const uniqueElims = eliminations.filter((v,i,a)=>a.findIndex(t=>(t.row === v.row && t.col===v.col && t.num === v.num))===i);

                    if (uniqueElims.length > 0) {
                        return {
                            type: 'Hidden Pair',
                            primaryCells,
                            secondaryCells: [],
                            eliminations: uniqueElims,
                            solve: null,
                        };
                    }
                }
            }
        }
    }
    return null;
};

const findNakedTriple = (board, targetCell) => {
    const units = [];
    if (targetCell) {
        const boxIndex = Math.floor(targetCell.row / 3) * 3 + Math.floor(targetCell.col / 3);
        units.push(getUnitCells('row', targetCell.row));
        units.push(getUnitCells('col', targetCell.col));
        units.push(getUnitCells('box', boxIndex));
    } else {
        for(let i=0; i<9; i++) {
            units.push(getUnitCells('row', i));
            units.push(getUnitCells('col', i));
            units.push(getUnitCells('box', i));
        }
    }

    for (const unit of units) {
        const candidateCells = unit.filter(cell => {
            const notes = getNotes(board, cell.row, cell.col);
            return notes.size > 1 && notes.size <= 3;
        });

        if (candidateCells.length < 3) continue;

        for (let i = 0; i < candidateCells.length; i++) {
            for (let j = i + 1; j < candidateCells.length; j++) {
                for (let k = j + 1; k < candidateCells.length; k++) {
                    const c1 = candidateCells[i], c2 = candidateCells[j], c3 = candidateCells[k];
                    const n1 = getNotes(board, c1.row, c1.col), n2 = getNotes(board, c2.row, c2.col), n3 = getNotes(board, c3.row, c3.col);
                    const combinedNotes = new Set([...n1, ...n2, ...n3]);

                    if (combinedNotes.size === 3) {
                        const primaryCells = [c1, c2, c3];
                        if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;

                        const tripleNums = [...combinedNotes];
                        const eliminations = [], secondaryCells = [];

                        for (const unitCell of unit) {
                            if (primaryCells.some(pc => pc.row === unitCell.row && pc.col === unitCell.col)) continue;
                            
                            const unitCellNotes = getNotes(board, unitCell.row, unitCell.col);
                            let madeElimination = false;
                            for (const num of tripleNums) {
                                if (unitCellNotes.has(num)) {
                                    eliminations.push({ row: unitCell.row, col: unitCell.col, num });
                                    madeElimination = true;
                                }
                            }
                            if (madeElimination) secondaryCells.push(unitCell);
                        }

                        if (eliminations.length > 0) {
                            const uniqueSecondary = secondaryCells.filter((v,i,a)=>a.findIndex(t=>(t.row === v.row && t.col===v.col))===i);
                            return {
                                type: 'Naked Triple',
                                primaryCells,
                                secondaryCells: uniqueSecondary,
                                eliminations,
                                solve: null,
                            };
                        }
                    }
                }
            }
        }
    }
    return null;
};

const findHiddenTriple = (board, targetCell) => {
    const units = [];
    if (targetCell) {
        const boxIndex = Math.floor(targetCell.row / 3) * 3 + Math.floor(targetCell.col / 3);
        units.push(getUnitCells('row', targetCell.row));
        units.push(getUnitCells('col', targetCell.col));
        units.push(getUnitCells('box', boxIndex));
    } else {
        for(let i=0; i<9; i++) {
            units.push(getUnitCells('row', i));
            units.push(getUnitCells('col', i));
            units.push(getUnitCells('box', i));
        }
    }
    
    for (const unit of units) {
        const candidateMap = new Map();
        for (let num = 1; num <= 9; num++) { candidateMap.set(num, []); }

        for (const cell of unit) {
            if (board[cell.row][cell.col].value === 0) {
                getNotes(board, cell.row, cell.col).forEach(num => {
                    candidateMap.get(num).push(cell);
                });
            }
        }

        const candidateNums = [];
        for (let num = 1; num <= 9; num++) {
            const cells = candidateMap.get(num);
            if (cells.length === 2 || cells.length === 3) candidateNums.push(num);
        }
        if (candidateNums.length < 3) continue;

        for (let i = 0; i < candidateNums.length; i++) {
            for (let j = i + 1; j < candidateNums.length; j++) {
                for (let k = j + 1; k < candidateNums.length; k++) {
                    const num1 = candidateNums[i], num2 = candidateNums[j], num3 = candidateNums[k];
                    const cells1 = candidateMap.get(num1), cells2 = candidateMap.get(num2), cells3 = candidateMap.get(num3);
                    const combinedCells = [...cells1, ...cells2, ...cells3];
                    const uniqueCellIds = new Set(combinedCells.map(c => `${c.row}-${c.col}`));
                    
                    if (uniqueCellIds.size === 3) {
                        const primaryCells = [...uniqueCellIds].map(id => ({ row: parseInt(id.split('-')[0]), col: parseInt(id.split('-')[1]) }));
                        if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                        
                        const tripleNums = new Set([num1, num2, num3]);
                        const eliminations = [];

                        for (const cell of primaryCells) {
                            getNotes(board, cell.row, cell.col).forEach(note => {
                                if (!tripleNums.has(note)) {
                                    eliminations.push({ row: cell.row, col: cell.col, num: note });
                                }
                            });
                        }

                        if (eliminations.length > 0) {
                            return {
                                type: 'Hidden Triple',
                                primaryCells,
                                secondaryCells: [],
                                eliminations,
                                solve: null,
                            };
                        }
                    }
                }
            }
        }
    }
    return null;
};

const findIntersectionRemoval = (board, targetCell) => {
    // Pointing
    for (let boxIndex = 0; boxIndex < 9; boxIndex++) {
        const boxCells = getUnitCells('box', boxIndex);
        for (let num = 1; num <= 9; num++) {
            const candidateCells = boxCells.filter(cell => getNotes(board, cell.row, cell.col).has(num));
            if (candidateCells.length < 2) continue;

            const rows = new Set(candidateCells.map(c => c.row));
            const cols = new Set(candidateCells.map(c => c.col));

            if (rows.size === 1) { // All candidates for num in this box are in the same row
                const row = rows.values().next().value;
                const rowCells = getUnitCells('row', row);
                const eliminations = [];
                for (const cell of rowCells) {
                    const inBox = Math.floor(cell.row / 3) * 3 + Math.floor(cell.col / 3) === boxIndex;
                    if (!inBox && getNotes(board, cell.row, cell.col).has(num)) {
                        eliminations.push({ row: cell.row, col: cell.col, num });
                    }
                }
                if (eliminations.length > 0) {
                    if (targetCell && !candidateCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                    const secondaryCells = eliminations.map(e => ({row: e.row, col: e.col}));
                    return { type: 'Pointing', primaryCells: candidateCells, secondaryCells, eliminations, solve: null };
                }
            }
            if (cols.size === 1) { // All candidates for num in this box are in the same col
                const col = cols.values().next().value;
                const colCells = getUnitCells('col', col);
                const eliminations = [];
                for (const cell of colCells) {
                    const inBox = Math.floor(cell.row / 3) * 3 + Math.floor(cell.col / 3) === boxIndex;
                    if (!inBox && getNotes(board, cell.row, cell.col).has(num)) {
                        eliminations.push({ row: cell.row, col: cell.col, num });
                    }
                }
                if (eliminations.length > 0) {
                    if (targetCell && !candidateCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                    const secondaryCells = eliminations.map(e => ({row: e.row, col: e.col}));
                    return { type: 'Pointing', primaryCells: candidateCells, secondaryCells, eliminations, solve: null };
                }
            }
        }
    }

    // Claiming
    for (let num = 1; num <= 9; num++) {
        for (let i = 0; i < 9; i++) {
            // Row Claiming
            const rowCells = getUnitCells('row', i);
            const rowCandidates = rowCells.filter(cell => getNotes(board, cell.row, cell.col).has(num));
            if (rowCandidates.length > 1) {
                const boxes = new Set(rowCandidates.map(c => Math.floor(c.row/3)*3 + Math.floor(c.col/3)));
                if (boxes.size === 1) {
                    const boxIndex = boxes.values().next().value;
                    const boxCells = getUnitCells('box', boxIndex);
                    const eliminations = [];
                    for(const cell of boxCells) {
                        if (cell.row !== i && getNotes(board, cell.row, cell.col).has(num)) {
                            eliminations.push({ row: cell.row, col: cell.col, num });
                        }
                    }
                    if (eliminations.length > 0) {
                         if (targetCell && !rowCandidates.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                         const secondaryCells = eliminations.map(e => ({row: e.row, col: e.col}));
                         return { type: 'Claiming', primaryCells: rowCandidates, secondaryCells, eliminations, solve: null };
                    }
                }
            }

            // Col Claiming
            const colCells = getUnitCells('col', i);
            const colCandidates = colCells.filter(cell => getNotes(board, cell.row, cell.col).has(num));
            if (colCandidates.length > 1) {
                const boxes = new Set(colCandidates.map(c => Math.floor(c.row/3)*3 + Math.floor(c.col/3)));
                if (boxes.size === 1) {
                    const boxIndex = boxes.values().next().value;
                    const boxCells = getUnitCells('box', boxIndex);
                    const eliminations = [];
                     for(const cell of boxCells) {
                        if (cell.col !== i && getNotes(board, cell.row, cell.col).has(num)) {
                            eliminations.push({ row: cell.row, col: cell.col, num });
                        }
                    }
                    if (eliminations.length > 0) {
                        if (targetCell && !colCandidates.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                        const secondaryCells = eliminations.map(e => ({row: e.row, col: e.col}));
                        return { type: 'Claiming', primaryCells: colCandidates, secondaryCells, eliminations, solve: null };
                    }
                }
            }
        }
    }
    return null;
};

const findXWing = (board, targetCell) => {
    for (let num = 1; num <= 9; num++) {
        // Row-based X-Wing
        const rowCandidates = [];
        for (let r = 0; r < 9; r++) {
            const cols = [];
            for (let c = 0; c < 9; c++) { if (getNotes(board, r, c).has(num)) { cols.push(c); } }
            if (cols.length === 2) { rowCandidates.push({ row: r, cols: cols }); }
        }

        if (rowCandidates.length >= 2) {
            for (let i = 0; i < rowCandidates.length; i++) {
                for (let j = i + 1; j < rowCandidates.length; j++) {
                    const r1 = rowCandidates[i], r2 = rowCandidates[j];
                    if (r1.cols[0] === r2.cols[0] && r1.cols[1] === r2.cols[1]) {
                        const c1 = r1.cols[0], c2 = r1.cols[1];
                        const primaryCells = [ { row: r1.row, col: c1 }, { row: r1.row, col: c2 }, { row: r2.row, col: c1 }, { row: r2.row, col: c2 }];
                        if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                        const eliminations = [];
                        for (let r = 0; r < 9; r++) {
                            if (r !== r1.row && r !== r2.row) {
                                if (getNotes(board, r, c1).has(num)) eliminations.push({ row: r, col: c1, num });
                                if (getNotes(board, r, c2).has(num)) eliminations.push({ row: r, col: c2, num });
                            }
                        }
                        if (eliminations.length > 0) {
                            const secondaryCells = eliminations.map(e => ({row: e.row, col: e.col}));
                            return { type: 'X-Wing', primaryCells, secondaryCells, eliminations, solve: null };
                        }
                    }
                }
            }
        }
    }
    return null;
};

const findSwordfish = (board, targetCell) => {
    for (let num = 1; num <= 9; num++) {
        // Row-based Swordfish
        const rowCandidates = [];
        for (let r = 0; r < 9; r++) {
            const cols = [];
            for (let c = 0; c < 9; c++) { if (getNotes(board, r, c).has(num)) { cols.push(c); } }
            if (cols.length === 2 || cols.length === 3) { rowCandidates.push({ row: r, cols }); }
        }

        if (rowCandidates.length >= 3) {
            for (let i = 0; i < rowCandidates.length; i++) {
                for (let j = i + 1; j < rowCandidates.length; j++) {
                    for (let k = j + 1; k < rowCandidates.length; k++) {
                        const r1 = rowCandidates[i], r2 = rowCandidates[j], r3 = rowCandidates[k];
                        const combinedCols = new Set([...r1.cols, ...r2.cols, ...r3.cols]);
                        if (combinedCols.size === 3) {
                            const [c1, c2, c3] = [...combinedCols].sort();
                            const primaryRows = [r1.row, r2.row, r3.row];
                            const primaryCells = [];
                            primaryRows.forEach(r => {
                                [c1, c2, c3].forEach(c => {
                                    if(getNotes(board, r, c).has(num)) primaryCells.push({row: r, col: c});
                                });
                            });
                            
                            if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;

                            const eliminations = [];
                            for (let r = 0; r < 9; r++) {
                                if (!primaryRows.includes(r)) {
                                    if (getNotes(board, r, c1).has(num)) eliminations.push({ row: r, col: c1, num });
                                    if (getNotes(board, r, c2).has(num)) eliminations.push({ row: r, col: c2, num });
                                    if (getNotes(board, r, c3).has(num)) eliminations.push({ row: r, col: c3, num });
                                }
                            }
                            if (eliminations.length > 0) {
                                const secondaryCells = eliminations.map(e => ({row: e.row, col: e.col}));
                                return { type: 'Swordfish', primaryCells, secondaryCells, eliminations, solve: null };
                            }
                        }
                    }
                }
            }
        }
    }
    return null;
};


const findHint = (board, difficulty, targetCell) => {
    let hint = findNakedSingle(board, targetCell);
    if (hint) return hint;
    
    hint = findHiddenSingle(board, targetCell);
    if (hint) return hint;
    
    if (difficulty === 'hard' || difficulty === 'professional') {
        hint = findNakedPair(board, targetCell);
        if (hint) return hint;

        hint = findHiddenPair(board, targetCell);
        if (hint) return hint;

        hint = findNakedTriple(board, targetCell);
        if(hint) return hint;

        hint = findHiddenTriple(board, targetCell);
        if(hint) return hint;
    }
    
    if (difficulty === 'professional') {
        hint = findIntersectionRemoval(board, targetCell);
        if (hint) return hint;

        hint = findXWing(board, targetCell);
        if (hint) return hint;

        hint = findSwordfish(board, targetCell);
        if (hint) return hint;
    }

    return null;
};
// --- END HINT LOGIC SERVICE ---


// From App.tsx
const { useCallback } = React;

const initialStats = {
  gamesPlayed: 0,
  gamesWon: 0,
  totalMoves: 0,
  totalMistakes: 0,
  byDifficulty: {
    easy: { wins: 0, bestTime: null, totalTime: 0 },
    medium: { wins: 0, bestTime: null, totalTime: 0 },
    hard: { wins: 0, bestTime: null, totalTime: 0 },
    professional: { wins: 0, bestTime: null, totalTime: 0 },
  },
};

const victoryMessages = [
  "Perfectly solved, as all grids should be.", "This solve was... inevitable.", "Numbers... Assemble.", "That's my secret: I'm always thinking.", "Dread it. Run from it. The numbers arrive all the same.", "The Logic is strong with this one.", "This is the way.", "These are the digits you're looking for.", "We will watch your career with great interest.", "I find your lack of empty cells... pleasing.", "True Jedi.", "Never tell me the odds!", "It's over, puzzle. I have the high ground.", "One grid to rule them all.", "My precious... solution.", "Not all those who ponder are lost.", "Looks like victory is back on the menu.", "One does not simply solve this grid... but you did.", "Mischief Managed.", "You're a wizard, solver.", "10 points for that solve!", "He who controls the numbers controls the grid.", "That's got to be the best solver I've ever seen.", "Pencils? Where we're going, we don't need pencils.", "Houston, we have a solution.", "Are you not entertained?!", "This puzzle has been terminated.", "Calculated.", "What a solve!", "This is Sudoku!", "Steeeerike!", "Home Run!", "Nice shot!", "The numbers, Mason! I figured them out!", "All your boxes are belong to us.",
];

const SAVED_GAME_KEY = 'sudoku-saved-game';
const SUDOKU_STATS_KEY = 'sudoku-stats';

const serializeSets = (key, value) => {
  if (value instanceof Set) {
    return { __dataType: 'Set', value: [...value] };
  }
  return value;
};

const deserializeSets = (key, value) => {
  if (typeof value === 'object' && value !== null && value.__dataType === 'Set') {
    return new Set(value.value);
  }
  return value;
};

const deepCopyBoard = (board) => {
  return board.map(row => 
    row.map(cell => ({
      ...cell,
      userNotes: new Set(cell.userNotes),
      autoNotes: new Set(cell.autoNotes),
      eliminatedNotes: new Set(cell.eliminatedNotes),
    }))
  );
};

const App = () => {
  const [board, setBoard] = useState([]);
  const [puzzle, setPuzzle] = useState([]);
  const [solution, setSolution] = useState([]);
  const [selectedCell, setSelectedCell] = useState(null);
  const [isNotesMode, setIsNotesMode] = useState(false);
  const [history, setHistory] = useState([]);
  const [redoHistory, setRedoHistory] = useState([]);
  const [isGameWon, setIsGameWon] = useState(false);
  const [animationState, setAnimationState] = useState('idle');
  const [victoryMessage, setVictoryMessage] = useState('');
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [isStatsOpen, setIsStatsOpen] = useState(false);
  const [difficulty, setDifficulty] = useState(
    () => (localStorage.getItem('sudoku-difficulty')) || 'medium'
  );
  const [isAutoNotesEnabled, setIsAutoNotesEnabled] = useState(
    () => localStorage.getItem('sudoku-auto-notes') === 'true'
  );
  const [isHighlightNotesEnabled, setIsHighlightNotesEnabled] = useState(
    () => localStorage.getItem('sudoku-highlight-notes') === 'true'
  );
  const [isDarkMode, setIsDarkMode] = useState(() => {
    const savedMode = localStorage.getItem('sudoku-dark-mode');
    if (savedMode) return savedMode === 'true';
    return window.matchMedia?.('(prefers-color-scheme: dark)').matches ?? false;
  });
  const [stats, setStats] = useState(() => {
    try {
      const savedStats = localStorage.getItem(SUDOKU_STATS_KEY);
      return savedStats ? JSON.parse(savedStats) : initialStats;
    } catch (e) {
      console.error("Error loading stats:", e);
      return initialStats;
    }
  });
  const [activeHint, setActiveHint] = useState(null);
  const [isHintOnCooldown, setIsHintOnCooldown] = useState(false);
  const [hintUsageCount, setHintUsageCount] = useState(0);
  const [hintCooldownDuration, setHintCooldownDuration] = useState(4);
  const [hintEffect, setHintEffect] = useState(null);
  const [hintButtonEffect, setHintButtonEffect] = useState(null);
  const cooldownIntervalRef = useRef(null);
  
  const [elapsedTime, setElapsedTime] = useState(0);
  const [isTimerRunning, setIsTimerRunning] = useState(false);
  const [movesCount, setMovesCount] = useState(0);
  const [mistakesCount, setMistakesCount] = useState(0);
  const [isTimerVisible, setIsTimerVisible] = useState(
    () => localStorage.getItem('sudoku-timer-visible') === 'true'
  );

  useEffect(() => {
    localStorage.setItem('sudoku-timer-visible', String(isTimerVisible));
  }, [isTimerVisible]);

  useEffect(() => {
    if (hintEffect) {
        const timer = setTimeout(() => setHintEffect(null), 800);
        return () => clearTimeout(timer);
    }
  }, [hintEffect]);
  
  useEffect(() => {
    if (hintButtonEffect) {
        const timer = setTimeout(() => setHintButtonEffect(null), 250);
        return () => clearTimeout(timer);
    }
  }, [hintButtonEffect]);

  useEffect(() => {
    return () => {
      if (cooldownIntervalRef.current) {
        clearInterval(cooldownIntervalRef.current);
      }
    };
  }, []);

  const startCooldown = useCallback(() => {
    if (cooldownIntervalRef.current) clearInterval(cooldownIntervalRef.current);
    const currentDuration = 4; // Fixed 4 seconds for testing
    setHintCooldownDuration(currentDuration);
    setIsHintOnCooldown(true);
    let timer = currentDuration;
    cooldownIntervalRef.current = window.setInterval(() => {
      timer -= 1;
      if (timer <= 0) {
        clearInterval(cooldownIntervalRef.current);
        setIsHintOnCooldown(false);
      }
    }, 1000);
  }, []);

  useEffect(() => {
    document.body.classList.toggle('dark', isDarkMode);
    localStorage.setItem('sudoku-dark-mode', String(isDarkMode));
  }, [isDarkMode]);

  useEffect(() => {
    localStorage.setItem('sudoku-auto-notes', String(isAutoNotesEnabled));
  }, [isAutoNotesEnabled]);
  
  useEffect(() => {
    localStorage.setItem(SUDOKU_STATS_KEY, JSON.stringify(stats));
  }, [stats]);

  useEffect(() => {
    localStorage.setItem('sudoku-highlight-notes', String(isHighlightNotesEnabled));
  }, [isHighlightNotesEnabled]);
  
  const isUIBlocked = isSettingsOpen || isStatsOpen;

  // This effect runs the timer
  useEffect(() => {
    let intervalId;
    if (isTimerRunning) {
      intervalId = setInterval(() => {
        setElapsedTime(prevTime => prevTime + 1000);
      }, 1000);
    }
    return () => clearInterval(intervalId);
  }, [isTimerRunning]);

  // This effect controls the timer's running state based on UI blocks and visibility
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (isGameWon) return;
      // This check is important to not resume timer if a modal is open when user returns to tab
      if (!isUIBlocked) {
        setIsTimerRunning(!document.hidden);
      }
    };

    if (isUIBlocked || isGameWon) {
      setIsTimerRunning(false);
    } else {
      setIsTimerRunning(!document.hidden);
    }

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [isUIBlocked, isGameWon]);
  
  const clearAllHintEffects = useCallback(() => {
    setActiveHint(null);
  }, []);

  const triggerWinState = useCallback(() => {
    setIsTimerRunning(false); // Stop the timer
    const randomMessage = victoryMessages[Math.floor(Math.random() * victoryMessages.length)];
    const gameDuration = elapsedTime;
    
    setStats(prev => {
        const difficultyStats = prev.byDifficulty[difficulty];
        const newBestTime = difficultyStats.bestTime === null || gameDuration < difficultyStats.bestTime 
          ? gameDuration 
          : difficultyStats.bestTime;
        return {
          ...prev,
          gamesWon: prev.gamesWon + 1,
          totalMoves: prev.totalMoves + movesCount,
          totalMistakes: prev.totalMistakes + mistakesCount,
          byDifficulty: {
            ...prev.byDifficulty,
            [difficulty]: {
              wins: difficultyStats.wins + 1,
              bestTime: newBestTime,
              totalTime: difficultyStats.totalTime + gameDuration,
            }
          }
        };
      });

    setVictoryMessage(randomMessage);
    setIsGameWon(true);
    setSelectedCell(null);
    clearAllHintEffects();
    localStorage.removeItem(SAVED_GAME_KEY);
  }, [clearAllHintEffects, elapsedTime, difficulty, movesCount, mistakesCount]);

  const checkWinCondition = useCallback((currentBoard) => {
    if (solution.length === 0) return false;
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        if (currentBoard[r][c].value === 0 || currentBoard[r][c].value !== solution[r][c]) {
          return false;
        }
      }
    }
    return true;
  }, [solution]);
  
  const startNewGame = useCallback((gameDifficulty) => {
    const { puzzle: newPuzzle, solution: newSolution } = generateSudoku(gameDifficulty);
    
    setStats(prev => ({ ...prev, gamesPlayed: prev.gamesPlayed + 1 }));
    
    setPuzzle(newPuzzle);
    setSolution(newSolution);

    let newBoard = newPuzzle.map(row =>
      row.map(value => ({
        value, isInitial: value !== 0, isWrong: false,
        userNotes: new Set(), autoNotes: new Set(), eliminatedNotes: new Set(),
      }))
    );

    if (isAutoNotesEnabled) {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (newBoard[r][c].value === 0) {
            newBoard[r][c].autoNotes = calculateCandidates(newBoard, r, c);
          }
        }
      }
    }

    setBoard(newBoard);
    setSelectedCell(null);
    setIsNotesMode(false);
    setHistory([]);
    setRedoHistory([]);
    setIsGameWon(false);
    setAnimationState('idle');
    clearAllHintEffects();
    
    setIsHintOnCooldown(false);
    if (cooldownIntervalRef.current) {
      clearInterval(cooldownIntervalRef.current);
    }
    setHintUsageCount(0);

    setElapsedTime(0);
    setIsTimerRunning(true);
    setMovesCount(0);
    setMistakesCount(0);
  }, [isAutoNotesEnabled, clearAllHintEffects]);

  useEffect(() => {
    const savedGameJson = localStorage.getItem(SAVED_GAME_KEY);
    if (savedGameJson) {
      try {
        const savedGame = JSON.parse(savedGameJson, deserializeSets);
        setBoard(savedGame.board);
        setPuzzle(savedGame.puzzle);
        setSolution(savedGame.solution);
        setHistory(savedGame.history || []);
        setRedoHistory(savedGame.redoHistory || []);
        setElapsedTime(savedGame.elapsedTime || 0);
        setMovesCount(savedGame.movesCount);
        setMistakesCount(savedGame.mistakesCount);
        setHintUsageCount(savedGame.hintUsageCount || 0);
        if (savedGame.difficulty && savedGame.difficulty !== difficulty) {
            setDifficulty(savedGame.difficulty);
            localStorage.setItem('sudoku-difficulty', savedGame.difficulty);
        }
      } catch (e) {
        console.error("Error loading saved game:", e);
        localStorage.removeItem(SAVED_GAME_KEY);
        startNewGame(difficulty);
      }
    } else {
      startNewGame(difficulty);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (board.length === 0 || isGameWon) return;
    const gameState = { board, puzzle, solution, history, redoHistory, elapsedTime, movesCount, mistakesCount, difficulty, hintUsageCount };
    localStorage.setItem(SAVED_GAME_KEY, JSON.stringify(gameState, serializeSets));
  }, [board, puzzle, solution, history, redoHistory, elapsedTime, movesCount, mistakesCount, difficulty, isGameWon, hintUsageCount]);
  
  useEffect(() => {
    if (isGameWon) {
      setAnimationState('playing');
      const timer = setTimeout(() => setAnimationState('finished'), 1500);
      return () => clearTimeout(timer);
    }
  }, [isGameWon]);

  const handleCellClick = (row, col) => {
    if (isGameWon) return;
    if (activeHint) {
      clearAllHintEffects();
    }
    if (selectedCell?.row === row && selectedCell?.col === col) {
      setSelectedCell(null);
    } else {
      setSelectedCell({ row, col });
    }
  };

  const placeNumberOnBoard = useCallback((row, col, num, isFromHint = false) => {
    setHistory(prev => [...prev, board]);
    setRedoHistory([]);
    clearAllHintEffects();
    const newBoard = deepCopyBoard(board);
    const cell = newBoard[row][col];
    if (!isFromHint) setMovesCount(prev => prev + 1);
    cell.value = num;
    cell.userNotes.clear(); cell.autoNotes.clear(); cell.eliminatedNotes.clear();
    const isCorrect = solution[row][col] === num;
    cell.isWrong = !isCorrect;
    if (!isCorrect && !isFromHint) setMistakesCount(prev => prev + 1);
    if (isCorrect) {
        if (!isFromHint) {
            setSelectedCell(null);
        }
        for (let c = 0; c < 9; c++) { newBoard[row][c].userNotes.delete(num); newBoard[row][c].autoNotes.delete(num); }
        for (let r = 0; r < 9; r++) { newBoard[r][col].userNotes.delete(num); newBoard[r][col].autoNotes.delete(num); }
        const boxStartRow = Math.floor(row / 3) * 3;
        const boxStartCol = Math.floor(col / 3) * 3;
        for (let r = boxStartRow; r < boxStartRow + 3; r++) {
            for (let c = boxStartCol; c < boxStartCol + 3; c++) {
                newBoard[r][c].userNotes.delete(num); newBoard[r][c].autoNotes.delete(num);
            }
        }
        if (checkWinCondition(newBoard)) triggerWinState();
    }
    setBoard(newBoard);
  }, [board, solution, clearAllHintEffects, checkWinCondition, triggerWinState]);

  const handleNumberClick = useCallback((num) => {
    if (!selectedCell || isGameWon || solution.length === 0) return;
    const { row, col } = selectedCell;
    const cellData = board[row][col];
    if (cellData.isInitial) return;
    if (isNotesMode) {
        if (cellData.eliminatedNotes.has(num)) return;
        if (!cellData.eliminatedNotes.has(num)) {
            setHistory(prev => [...prev, board]);
            setRedoHistory([]);
            clearAllHintEffects();
            const newBoard = deepCopyBoard(board);
            const cell = newBoard[row][col];
            const isAdding = !cell.userNotes.has(num) && !cell.autoNotes.has(num);
            if (isAdding) cell.userNotes.add(num);
            else { cell.userNotes.delete(num); cell.autoNotes.delete(num); }
            cell.value = 0;
            setBoard(newBoard);
        }
    } else {
        placeNumberOnBoard(row, col, num);
    }
  }, [board, isNotesMode, selectedCell, isGameWon, solution, clearAllHintEffects, placeNumberOnBoard]);
  
  const handleToggleNotesMode = useCallback(() => { if (!isGameWon) setIsNotesMode(prev => !prev); }, [isGameWon]);
  
  const handleUndo = useCallback(() => {
    if (history.length === 0 || isGameWon) return;
    setRedoHistory(prev => [...prev, board]);
    setBoard(history[history.length - 1]);
    setHistory(history.slice(0, -1));
    clearAllHintEffects();
  }, [board, history, isGameWon, clearAllHintEffects]);

  const handleRedo = useCallback(() => {
    if (redoHistory.length === 0 || isGameWon) return;
    setHistory(prev => [...prev, board]);
    setBoard(redoHistory[redoHistory.length - 1]);
    setRedoHistory(redoHistory.slice(0, -1));
    clearAllHintEffects();
  }, [board, redoHistory, isGameWon, clearAllHintEffects]);

  const handleDelete = useCallback(() => {
    if (!selectedCell || isGameWon) return;
    const { row, col } = selectedCell;
    const cellToDelete = board[row][col];
    if (cellToDelete.isInitial || (cellToDelete.value === 0 && cellToDelete.userNotes.size === 0 && cellToDelete.autoNotes.size === 0 && cellToDelete.eliminatedNotes.size === 0)) return;
    setHistory(prev => [...prev, board]);
    setRedoHistory([]);
    clearAllHintEffects();
    const newBoard = deepCopyBoard(board);
    const cell = newBoard[row][col];
    cell.value = 0;
    cell.userNotes.clear(); cell.autoNotes.clear(); cell.eliminatedNotes.clear();
    cell.isWrong = false;
    setBoard(newBoard);
  }, [board, selectedCell, isGameWon, clearAllHintEffects]);

  const handleHint = useCallback(() => {
    if (isHintOnCooldown || isGameWon || solution.length === 0) return;

    if (activeHint) {
        if (activeHint.solve) {
            const { row, col, num } = activeHint.solve;
            placeNumberOnBoard(row, col, num, true);
        } else if (activeHint.eliminations?.length > 0) {
            setHistory(prev => [...prev, board]);
            setRedoHistory([]);
            const newBoard = deepCopyBoard(board);
            activeHint.eliminations.forEach(({ row, col, num }) => {
                const cellToUpdate = newBoard[row][col];
                cellToUpdate.eliminatedNotes.add(num);
                cellToUpdate.userNotes.delete(num);
                cellToUpdate.autoNotes.delete(num);
            });
            setBoard(newBoard);
            setHintEffect({ type: 'note-pop', eliminations: activeHint.eliminations });
        }
        clearAllHintEffects();
        return;
    }

    const hint = findHint(board, difficulty, selectedCell);

    if (hint) {
        setActiveHint(hint);
        if (hint.primaryCells.length === 1 && hint.solve) {
            setHintEffect({ type: 'cell-glow', cell: hint.primaryCells[0] });
        }
        startCooldown();
        setHintUsageCount(prev => prev + 1);
    } else {
        setHintButtonEffect('shake');
    }
  }, [board, isHintOnCooldown, selectedCell, isGameWon, solution, activeHint, difficulty, placeNumberOnBoard, clearAllHintEffects, startCooldown]);

  const handleFillBoard = useCallback(() => {
    if (solution.length === 0) return;
    const solvedBoard = solution.map(row => row.map(value => ({
      value, isInitial: false, isWrong: false,
      userNotes: new Set(), autoNotes: new Set(), eliminatedNotes: new Set(),
    })));
    setBoard(solvedBoard);
    triggerWinState();
  }, [solution, triggerWinState]);

  const handleFillBoardAndCloseSettings = () => {
    setIsSettingsOpen(false);
    setTimeout(() => handleFillBoard(), 300); 
  };
  
  const handleCloseSettings = (newDifficulty) => {
    setIsSettingsOpen(false);
    if (newDifficulty !== difficulty) {
      setDifficulty(newDifficulty);
      localStorage.setItem('sudoku-difficulty', newDifficulty);
      startNewGame(newDifficulty);
    }
  };

  const handleSetAutoNotes = (enabled) => {
    setIsAutoNotesEnabled(enabled);
    const newBoard = deepCopyBoard(board);
    if (enabled) {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (newBoard[r][c].value === 0 && newBoard[r][c].userNotes.size === 0) {
            newBoard[r][c].autoNotes = calculateCandidates(newBoard, r, c);
          } else {
            newBoard[r][c].autoNotes.clear();
          }
        }
      }
    } else {
      newBoard.forEach(row => row.forEach(cell => cell.autoNotes.clear()));
    }
    setHistory(prev => [...prev, board]);
    setRedoHistory([]);
    setBoard(newBoard);
  };
  
  useEffect(() => {
    const handleKeyDown = (event) => {
      if (isGameWon || isSettingsOpen || isStatsOpen) return;
      if (!selectedCell && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
        setSelectedCell({ row: 0, col: 0 });
        event.preventDefault();
        return;
      }
      if (!selectedCell) return;
      const { row, col } = selectedCell;
      switch (event.key) {
        case 'ArrowUp': setSelectedCell({ row: Math.max(0, row - 1), col }); event.preventDefault(); break;
        case 'ArrowDown': setSelectedCell({ row: Math.min(8, row + 1), col }); event.preventDefault(); break;
        case 'ArrowLeft': setSelectedCell({ row, col: Math.max(0, col - 1) }); event.preventDefault(); break;
        case 'ArrowRight': setSelectedCell({ row, col: Math.min(8, col + 1) }); event.preventDefault(); break;
        case 'Backspace': case 'Delete': handleDelete(); event.preventDefault(); break;
        case 'Escape': setSelectedCell(null); event.preventDefault(); break;
        default:
          const num = parseInt(event.key, 10);
          if (!isNaN(num) && num >= 1 && num <= 9) handleNumberClick(num);
          break;
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedCell, handleDelete, handleNumberClick, isGameWon, isSettingsOpen, isStatsOpen]);

  if (board.length === 0 || solution.length === 0) {
    return <div className="flex items-center justify-center min-h-screen">Generating Puzzle...</div>;
  }
  
  const formatTime = (milliseconds) => {
    if (!milliseconds || milliseconds < 0) return '0:00';
    const totalSeconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  const highlightedNumber = selectedCell && board[selectedCell.row][selectedCell.col].value > 0
    ? board[selectedCell.row][selectedCell.col].value : null;

  return (
    <div className={`min-h-screen font-sans relative`} onClick={() => setSelectedCell(null)}>
      <Header 
          isDarkMode={isDarkMode} 
          onOpenSettings={() => setIsSettingsOpen(true)}
          onOpenStats={() => setIsStatsOpen(true)}
          onNewGame={() => startNewGame(difficulty)}
          elapsedTime={elapsedTime}
          isTimerVisible={isTimerVisible}
        />
      <div className={`min-h-screen flex flex-col items-center justify-center pt-24 sm:pt-32 pb-4 sm:pb-8 px-4`}>
        <main className={`w-full max-w-lg flex flex-col items-center gap-2 sm:gap-4 transition-all duration-300 ${isUIBlocked ? 'blur-sm pointer-events-none' : ''}`}>
          <div className="relative w-full h-8 mb-1">
            <div className={`absolute inset-0 flex items-center justify-center transition-opacity duration-300 ${activeHint ? 'opacity-100' : 'opacity-0'}`}>
                {activeHint && (
                    <div className={`px-4 py-1 rounded-full text-sm font-bold shadow-md ${isDarkMode ? 'bg-slate-700 text-amber-300' : 'bg-slate-200 text-slate-700'}`}>
                        {activeHint.type}
                    </div>
                )}
            </div>
          </div>
          <div className="relative w-full" onClick={(e) => e.stopPropagation()}>
            {animationState !== 'idle' && (
              <VictoryScreen 
                message={victoryMessage}
                moves={movesCount}
                time={formatTime(elapsedTime)}
                mistakes={mistakesCount}
              />
            )}
            <SudokuBoard 
              board={board}
              solution={solution}
              selectedCell={selectedCell}
              onCellClick={handleCellClick}
              isNotesMode={isNotesMode}
              isDarkMode={isDarkMode}
              forceDarkMode={isGameWon}
              isAutoNotesEnabled={isAutoNotesEnabled}
              isHighlightNotesEnabled={isHighlightNotesEnabled}
              highlightedNumber={highlightedNumber}
              activeHint={activeHint}
              hintEffect={hintEffect}
            />
          </div>
          <div className="relative w-full flex flex-col items-center gap-2">
              <div className={`w-full transition-opacity duration-300 ease-in-out ${isGameWon ? 'opacity-0 pointer-events-none' : 'opacity-100'}`} onClick={(e) => e.stopPropagation()}>
                  <div className={`transition-transform duration-500 ease-in-out ${isGameWon ? 'translate-y-8' : ''}`}>
                      <NumberPad onNumberClick={handleNumberClick} isNotesMode={isNotesMode} isDarkMode={isDarkMode} />
                  </div>
              </div>
              <div className="relative w-full flex justify-center" style={{minHeight: '80px'}}>
                  <div className={`absolute inset-0 flex flex-col items-center justify-center transition-opacity duration-300 ease-in-out ${isGameWon ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}>
                      <div className={`transition-transform duration-500 ease-in-out ${isGameWon ? '-translate-y-8' : ''}`} onClick={(e) => e.stopPropagation()}>
                          <Controls 
                              isNotesMode={isNotesMode} onToggleNotesMode={handleToggleNotesMode} onUndo={handleUndo}
                              canUndo={history.length > 0} onRedo={handleRedo} canRedo={redoHistory.length > 0}
                              onHint={handleHint} isHintOnCooldown={isHintOnCooldown}
                              cooldownDuration={hintCooldownDuration} onDelete={handleDelete} isDarkMode={isDarkMode}
                              hintButtonEffect={hintButtonEffect}
                          />
                      </div>
                  </div>
                  <div className={`absolute inset-0 flex items-center justify-center transition-all duration-500 ease-in-out transform ${isGameWon ? 'opacity-100 scale-100' : 'opacity-0 scale-95 pointer-events-none'}`} style={{transitionDelay: isGameWon ? '250ms' : '0ms'}}>
                      <div className="relative w-auto rounded-full p-1 shadow-lg bg-slate-800" onClick={(e) => e.stopPropagation()}>
                          <button
                              onClick={() => startNewGame(difficulty)}
                              className="w-auto bg-slate-800 text-white font-bold py-4 px-16 rounded-full text-2xl hover:bg-slate-700/80 transition-colors transform active:scale-95 flex items-center justify-center"
                          >
                              <span className={`transition-opacity duration-300 ease-in-out ${isGameWon ? 'opacity-100' : 'opacity-0'}`} style={{transitionDelay: isGameWon ? '400ms' : '0ms'}}>
                                Play Again
                              </span>
                          </button>
                      </div>
                  </div>
              </div>
          </div>
        </main>
      </div>
      <SettingsPanel
        isOpen={isSettingsOpen} onClose={handleCloseSettings} currentDifficulty={difficulty}
        isDarkMode={isDarkMode} onToggleDarkMode={() => setIsDarkMode(prev => !prev)}
        onFillBoard={handleFillBoardAndCloseSettings} isAutoNotesEnabled={isAutoNotesEnabled}
        onSetAutoNotes={handleSetAutoNotes} isHighlightNotesEnabled={isHighlightNotesEnabled}
        onSetHighlightNotes={setIsHighlightNotesEnabled}
        isTimerVisible={isTimerVisible}
        onSetIsTimerVisible={setIsTimerVisible}
      />
      <StatsPanel isOpen={isStatsOpen} onClose={() => setIsStatsOpen(false)} stats={stats} isDarkMode={isDarkMode} />
    </div>
  );
};

// From index.tsx
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
    </script>
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('sw.js')
            .then(registration => {
              console.log('Service Worker registered with scope:', registration.scope);
            })
            .catch(error => {
              console.error('Service Worker registration failed:', error);
            });
        });
      }
    </script>
  </body>
</html>
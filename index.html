<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="public/icon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>Sudoku</title>
    
    <!-- PWA Manifest and Theme -->
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#0f172a" />
    
    <!-- PWA Meta Tags for iOS & Android -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Sudoku" />
    <link rel="apple-touch-icon" href="public/icon.svg" />

    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        /* Default Theme - Light */
        --color-page-bg: #eef1f5;
        --color-text-primary: #111827;
        --color-text-secondary: #4b5563;
        --color-accent: #2563eb;
        --color-accent-text: #ffffff;
        --color-accent-hover: #1d4ed8;
      }
      body {
        font-family: 'Inter', sans-serif;
        background-color: var(--color-page-bg);
        transition: background-color 0.5s ease-in-out;
      }
      
      @keyframes shake {
        10%, 90% { transform: translate3d(-1px, 0, 0); }
        20%, 80% { transform: translate3d(2px, 0, 0); }
        30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
        40%, 60% { transform: translate3d(4px, 0, 0); }
      }
      .animate-shake {
          animation: shake 0.25s cubic-bezier(.36,.07,.19,.97) both;
      }
      
      @keyframes pop {
        0% { transform: scale(1); }
        50% { transform: scale(1.3); }
        100% { transform: scale(1); }
      }
      .animate-pop {
        animation: pop 0.2s ease-in-out;
      }

      @keyframes rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      .animate-rotate {
        animation: rotate 0.5s ease-in-out;
      }

      @keyframes hint-pop-glow {
        0% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7); }
        100% { box-shadow: 0 0 10px 25px rgba(251, 191, 36, 0); }
      }
      .animate-hint-pop {
        animation: hint-pop-glow 0.4s ease-out;
      }

      @keyframes hint-refill-glow {
        0% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.5); }
        100% { box-shadow: 0 0 8px 15px rgba(251, 191, 36, 0); }
      }
      .animate-hint-refill {
        animation: hint-refill-glow 0.3s ease-out;
      }

      @keyframes hint-cell-glow {
        0% { box-shadow: 0 0 0px 0px rgba(251, 191, 36, 0.7); }
        50% { box-shadow: 0 0 12px 6px rgba(251, 191, 36, 0.7); }
        100% { box-shadow: 0 0 0px 0px rgba(251, 191, 36, 0); }
      }
      .animate-hint-cell {
        animation: hint-cell-glow 0.8s ease-out;
      }

      @keyframes fill-up {
        from { clip-path: inset(100% 0 0 0); }
        to { clip-path: inset(0% 0 0 0); }
      }
      .animate-fill-up {
        /* The duration is set dynamically via inline styles */
        animation-name: fill-up;
        animation-timing-function: linear;
        animation-fill-mode: forwards;
      }
    </style>
    <!--
      The following scripts are required to run this React application
      directly from a local file (`file://...`) without a build step.
    -->
    <!-- 1. React and ReactDOM libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- 2. Babel Standalone: Transpiles JSX (.tsx files) into plain JavaScript in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
  <body>
    <div id="root"></div>
    <!--
      All application code is consolidated into this single script block.
      We use `type="text/babel"` and `data-presets` to tell Babel Standalone to transform this code.
      This avoids making external file requests, which are blocked by browser security on the `file://` protocol.
    -->
    <script type="text/babel" data-presets="react,typescript">
      const { useState, useEffect, useCallback, useRef, StrictMode, Fragment } = React;

      // --- services/tutorialService.ts ---
      
      const tutorialData = {
        'Naked Single': {
          title: 'Naked Single',
          description: "A 'Naked Single' occurs when a cell has only one possible number (note) remaining. This number must be the solution for that cell.",
          graphic: [
            [{ value: 4 }, { value: 6 }, { notes: [5, 8] }],
            [{ value: 1 }, { notes: [5], highlights: { cell: 'primary'} }, { value: 9 }],
            [{ value: 2 }, { value: 7 }, { value: 3 }],
          ],
        },
        'Hidden Single': {
          title: 'Hidden Single',
          description: "A 'Hidden Single' is found when a specific number can only be placed in one cell within a row, column, or box. It is the only place for that note (e.g., the '4'), so it must be the solution for that cell.",
          graphic: [
            [{ value: 1 }, { notes: [3,8] }, { value: 9 }, { notes: [3,7] }, { notes: [4,7], highlights: { cell: 'primary', notes: {'4': 'primary'} } }, { value: 6 }, { notes: [2,5] }, { notes: [2,3,5] }, { value: 8 }],
          ],
        },
        'Naked Pair': {
          title: 'Naked Pair',
          description: "When two cells in the same unit (row, column, or box) have the exact same two notes, it's a 'Naked Pair'. Those two numbers must go in those two cells, so you can eliminate them from all other cells in that unit.",
          graphic: [
            [{ value: 1 }, { notes: [2, 8], highlights: { cell: 'primary' } }, { notes: [2, 8], highlights: { cell: 'primary' } }, { notes: [2, 4, 5], highlights: { cell: 'secondary', notes: { '2': 'elim' } } }, { value: 9 }],
          ],
        },
        'Hidden Pair': {
          title: 'Hidden Pair',
          description: "A 'Hidden Pair' occurs when two notes (e.g., 4 and 7) appear in only two cells within a unit. You can eliminate all other notes from those two cells.",
          graphic: [
            [
              { notes: [1, 4, 7], highlights: { cell: 'primary', notes: { '1': 'elim', '4': 'primary', '7': 'primary' } } },
              { notes: [1, 3, 9] },
              { notes: [3, 4, 7], highlights: { cell: 'primary', notes: { '3': 'elim', '4': 'primary', '7': 'primary' } } }
            ],
            [
              { notes: [1, 5, 8] },
              { value: 2 },
              { notes: [1, 3, 5] }
            ],
            [
              { notes: [1, 9] },
              { value: 6 },
              { value: 5 }
            ],
          ],
        },
        'Naked Triple': {
          title: 'Naked Triple',
          description: "When three cells in a unit contain only notes from a set of three numbers (e.g., 1, 5, 8), it's a 'Naked Triple'. These three numbers can be eliminated from all other cells in that unit.",
          graphic: [
            [
              { notes: [1, 5], highlights: { cell: 'primary' } }, 
              { notes: [5, 8], highlights: { cell: 'primary' } }, 
              { notes: [1, 8], highlights: { cell: 'primary' } }, 
              { notes: [1, 4, 9], highlights: { cell: 'secondary', notes: { '1': 'elim' } } },
              { notes: [5, 6, 7], highlights: { cell: 'secondary', notes: { '5': 'elim' } } }
            ],
          ],
        },
        'Hidden Triple': {
          title: 'Hidden Triple',
          description: "A 'Hidden Triple' is when three numbers are candidates in only three cells within a unit. You can eliminate all other notes from these three cells.",
          graphic: [
            [
              { notes: [1, 2, 8, 9], highlights: { cell: 'primary', notes: { '1': 'primary', '2': 'primary', '8': 'elim', '9': 'elim' } } },
              { notes: [4, 5] },
              { notes: [2, 3, 7, 9], highlights: { cell: 'primary', notes: { '2': 'primary', '3': 'primary', '7': 'elim', '9': 'elim' } } },
            ],
            [
              { notes: [4, 6] },
              { notes: [1, 3, 5], highlights: { cell: 'primary', notes: { '1': 'primary', '3': 'primary', '5': 'elim' } } },
              { notes: [6, 7] },
            ],
            [
              { value: 8 },
              { value: 9 },
              { value: 7 },
            ],
          ]
        },
        'Pointing': {
          title: 'Pointing Pair/Triple',
          description: "When a number's candidates (e.g., '1') within a box are all in a single row or column, you can eliminate that number from other cells in that row/column outside the box.",
          graphic: [
              [{notes: [1,2]}, {notes: [1,2], highlights: {cell: 'primary'}}, {notes: [1,2], highlights: {cell: 'primary'}}, {notes: [1,7,8], highlights: {cell: 'secondary', notes: {'1': 'elim'}}}, {value: 9}],
              [{notes: [3,4]}, {notes: [3,4]}, {notes: [3,4]}, {value: 5}, {value: 6}],
              [{notes: [5,6]}, {notes: [5,6]}, {notes: [5,6]}, {value: 2}, {value: 3}],
          ]
        },
        'Claiming': {
          title: 'Claiming Pair/Triple',
          description: "When a number's candidates (e.g., '1') within a row or column are all in a single box, you can eliminate that number from other cells in that box.",
           graphic: [
              [{notes: [1,2], highlights: {cell: 'primary'}}, {notes: [7,8]}, {notes: [7,8]}],
              [{notes: [1,2], highlights: {cell: 'primary'}}, {value: 3}, {value: 4}],
              [{notes: [5,6]}, {notes: [1,9], highlights: {cell: 'secondary', notes: {'1': 'elim'}}}, {notes: [1,3], highlights: {cell: 'secondary', notes: {'1': 'elim'}}}],
          ]
        },
        'X-Wing': {
          title: 'X-Wing',
          description: "In two rows, a number (e.g. '5') appears as a candidate in the exact same two columns. This 'X' pattern means you can eliminate that number from all other cells in those columns.",
          graphic: [
              [{value: 1}, {notes: [5,8], highlights: {cell: 'primary'}}, {value: 3}, {notes: [5,9], highlights: {cell: 'primary'}}, {value: 2}],
              [{value: 4}, {notes: [2,5], highlights: {cell: 'secondary', notes: {'5': 'elim'}}}, {value: 6}, {value: 7}, {value: 8}],
              [{value: 6}, {value: 7}, {value: 1}, {notes: [2,5], highlights: {cell: 'secondary', notes: {'5': 'elim'}}}, {value: 3}],
              [{value: 9}, {notes: [5,8], highlights: {cell: 'primary'}}, {value: 2}, {notes: [5,9], highlights: {cell: 'primary'}}, {value: 1}],
          ]
        },
        'Swordfish': {
          title: 'Swordfish',
          description: "In three rows, a number (e.g., '2') appears as a candidate in only the same three columns. You can eliminate that number from all other cells in those three columns.",
          graphic: [
            [{notes: [2,8], highlights:{cell:'primary'}}, {notes: [2,9], highlights:{cell:'secondary', notes:{'2':'elim'}}}, {notes: [2,8], highlights:{cell:'primary'}}, {value: 3}, {notes: [2,8], highlights:{cell:'primary'}}],
            [{value: 3}, {value: 1}, {value: 4}, {value: 5}, {value: 6}],
            [{notes: [2,8], highlights:{cell:'primary'}}, {value: 7}, {notes: [2,8], highlights:{cell:'primary'}}, {value: 9}, {notes: [2,8], highlights:{cell:'primary'}}],
            [{value: 4}, {notes: [2,9], highlights:{cell:'secondary', notes:{'2':'elim'}}}, {value: 6}, {value: 7}, {value: 8}],
            [{notes: [2,8], highlights:{cell:'primary'}}, {value: 9}, {notes: [2,8], highlights:{cell:'primary'}}, {value: 1}, {notes: [2,8], highlights:{cell:'primary'}}],
          ]
        },
        'Jellyfish': {
          title: 'Jellyfish',
          description: "In four rows, a number (e.g., '7') appears as a candidate in only the same four columns. You can eliminate that number from all other cells in those four columns.",
          graphic: [
            [{notes:[7], highlights:{cell:'primary'}}, {value:1}, {notes:[7], highlights:{cell:'primary'}}, {value:2}, {notes:[7], highlights:{cell:'primary'}}, {notes:[7], highlights:{cell:'primary'}}],
            [{value:3}, {notes:[7,9], highlights:{cell:'secondary', notes:{'7':'elim'}}}, {value:4}, {value:5}, {value:6}, {value:8}],
            [{notes:[7], highlights:{cell:'primary'}}, {value:2}, {notes:[7], highlights:{cell:'primary'}}, {value:3}, {notes:[7], highlights:{cell:'primary'}}, {notes:[7], highlights:{cell:'primary'}}],
            [{value:4}, {value:5}, {value:6}, {value:8}, {value:9}, {value:1}],
            [{notes:[7], highlights:{cell:'primary'}}, {value:3}, {notes:[7], highlights:{cell:'primary'}}, {value:4}, {notes:[7], highlights:{cell:'primary'}}, {notes:[7], highlights:{cell:'primary'}}],
            [{notes:[7], highlights:{cell:'primary'}}, {value:6}, {notes:[7], highlights:{cell:'primary'}}, {value:1}, {notes:[7], highlights:{cell:'primary'}}, {notes:[7], highlights:{cell:'primary'}}],
          ]
        },
        'Skyscraper': {
          title: 'Skyscraper',
          description: "In two columns, a number (e.g., '5') appears twice. If two candidates share a row (the 'base'), the other two are 'rooftops'. You can eliminate '5' from any cell that sees both rooftops.",
          graphic: [
            [{notes: [5], highlights:{cell:'primary'}}, {value:1}, {value:2}, {value:3}],
            [{value:4}, {value:6}, {value:7}, {notes: [5], highlights:{cell:'primary'}}],
            [{value:8}, {value:9}, {value:1}, {value:2}],
            [{notes: [5], highlights:{cell:'primary'}}, {notes: [5,9], highlights:{cell:'secondary', notes:{'5':'elim'}}}, {value:3}, {notes: [5], highlights:{cell:'primary'}}],
          ]
        },
        'Two-String Kite': {
          title: 'Two-String Kite',
          description: "A number (e.g., '9') is a candidate in only two cells of a row, and two cells of a column. If one cell is shared, you can eliminate '9' from the cell that forms a rectangle with the other two ends.",
          graphic: [
            [{value:1}, {notes: [9], highlights:{cell:'primary'}}, {value:2}, {notes: [9], highlights:{cell:'primary'}}],
            [{value:3}, {value:4}, {value:5}, {value:6}],
            [{value:7}, {notes: [8,9], highlights:{cell:'secondary', notes:{'9':'elim'}}}, {value:1}, {notes: [9], highlights:{cell:'primary'}}]
          ]
        },
        'XY-Wing': {
          title: 'XY-Wing',
          description: "A 'pivot' cell (1,2) sees two 'pincer' cells (1,3) and (2,3). The note in common to the pincers ('3') can be eliminated from any cell that sees both pincers.",
          graphic: [
            [{notes: [1,2], highlights:{cell:'primary'}}, {value:4}, {value:5}, {notes: [1,3], highlights:{cell:'primary'}}],
            [{value:6}, {value:7}, {value:8}, {value:9}],
            [{value:2}, {value:1}, {value:3}, {value:4}],
            [{notes: [2,3], highlights:{cell:'primary'}}, {value:5}, {value:6}, {notes: [3,8], highlights:{cell:'secondary', notes:{'3':'elim'}}}]
          ]
        },
        'XYZ-Wing': {
          title: 'XYZ-Wing',
          description: "A 'pivot' cell has three notes (1,2,3). Two 'pincer' cells see it, each sharing one note with the pivot and one note ('3') with each other. '3' can be eliminated from any cell seeing all three.",
          graphic: [
            [{notes: [1,2,3], highlights:{cell:'primary'}}, {value:4}, {value:5}, {notes: [1,3], highlights:{cell:'primary'}}],
            [{value:6}, {value:7}, {value:8}, {value:9}],
            [{value:2}, {value:1}, {value:3}, {value:4}],
            [{notes: [2,3], highlights:{cell:'primary'}}, {value:5}, {value:6}, {notes: [3,8], highlights:{cell:'secondary', notes:{'3':'elim'}}}]
          ]
        },
        'Unique Rectangle': {
          title: 'Unique Rectangle',
          description: "When three corners of a rectangle have the same two notes (e.g., 4 & 8), you can eliminate those notes from the fourth corner to prevent multiple (illegal) solutions.",
          graphic: [
            [{notes: [4,8], highlights:{cell:'primary'}}, {value:1}, {notes: [4,8], highlights:{cell:'primary'}}],
            [{value:2}, {value:3}, {value:5}],
            [{notes: [4,8,9], highlights:{cell:'secondary', notes:{'4':'elim', '8': 'elim'}}}, {value:6}, {notes: [4,8], highlights:{cell:'primary'}}]
          ]
        }
      };
      
      const hintTypeMap = {
        'Naked Single': 'Naked Single',
        'Hidden Single': 'Hidden Single',
        'Naked Pair': 'Naked Pair',
        'Hidden Pair': 'Hidden Pair',
        'Naked Triple': 'Naked Triple',
        'Hidden Triple': 'Hidden Triple',
        'Intersection Removal': 'Pointing',
        'Pointing': 'Pointing',
        'Claiming': 'Claiming',
        'X-Wing': 'X-Wing',
        'Swordfish': 'Swordfish',
        'Jellyfish': 'Jellyfish',
        'Skyscraper': 'Skyscraper',
        'Two-String Kite': 'Two-String Kite',
        'XY-Wing': 'XY-Wing',
        'XYZ-Wing': 'XYZ-Wing',
        'Unique Rectangle': 'Unique Rectangle',
      };
      
      function getTutorialForHint(hintType) {
        if (!hintType) return null;
        const mappedType = hintTypeMap[hintType] || null;
        return mappedType ? tutorialData[mappedType] : null;
      }
      
      // --- services/hintService.ts ---
      
      const calculateCandidates = (currentBoard, row, col) => {
          const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
          const gridValues = currentBoard.map(r => r.map(c => c.value));
          for (let i = 0; i < 9; i++) {
              if (gridValues[row][i] !== 0) candidates.delete(gridValues[row][i]);
              if (gridValues[i][col] !== 0) candidates.delete(gridValues[i][col]);
          }
          const boxStartRow = Math.floor(row / 3) * 3;
          const boxStartCol = Math.floor(col / 3) * 3;
          for (let i = boxStartRow; i < boxStartRow + 3; i++) {
              for (let j = boxStartCol; j < boxStartCol + 3; j++) {
                  if (gridValues[i][j] !== 0) candidates.delete(gridValues[i][j]);
              }
          }
          return candidates;
      };
      
      const getNotes = (board, row, col) => {
          const cell = board[row][col];
          if (cell.value !== 0) return new Set();
          const candidates = calculateCandidates(board, row, col);
          cell.eliminatedNotes.forEach(eliminated => candidates.delete(eliminated));
          return candidates;
      };
      
      const getUnitCells = (type, index) => {
          const cells = [];
          if (type === 'row') {
              for (let c = 0; c < 9; c++) cells.push({ row: index, col: c });
          } else if (type === 'col') {
              for (let r = 0; r < 9; r++) cells.push({ row: r, col: index });
          } else if (type === 'box') {
              const boxStartRow = Math.floor(index / 3) * 3;
              const boxStartCol = (index % 3) * 3;
              for (let r = boxStartRow; r < boxStartRow + 3; r++) {
                  for (let c = boxStartCol; c < boxStartCol + 3; c++) {
                      cells.push({ row: r, col: c });
                  }
              }
          }
          return cells;
      };
      
      const findNakedSingle = (board, targetCell) => {
          const checkCell = (r, c) => {
              if (board[r][c].value === 0) {
                  const notes = getNotes(board, r, c);
                  if (notes.size === 1) {
                      const num = notes.values().next().value;
                      return {
                          type: 'Naked Single',
                          primaryCells: [{ row: r, col: c }],
                          secondaryCells: [],
                          eliminations: [],
                          solve: { row: r, col: c, num },
                      };
                  }
              }
              return null;
          }
          if (targetCell) return checkCell(targetCell.row, targetCell.col);
      
          for (let r = 0; r < 9; r++) {
              for (let c = 0; c < 9; c++) {
                  const hint = checkCell(r, c);
                  if (hint) return hint;
              }
          }
          return null;
      };
      
      const findHiddenSingle = (board, targetCell) => {
          const unitConfigs = [];
          if (targetCell) {
              const boxIndex = Math.floor(targetCell.row / 3) * 3 + Math.floor(targetCell.col / 3);
              unitConfigs.push({ type: 'row', index: targetCell.row, cells: getUnitCells('row', targetCell.row) });
              unitConfigs.push({ type: 'col', index: targetCell.col, cells: getUnitCells('col', targetCell.col) });
              unitConfigs.push({ type: 'box', index: boxIndex, cells: getUnitCells('box', boxIndex) });
          } else {
              for(let i=0; i<9; i++) {
                  unitConfigs.push({ type: 'row', index: i, cells: getUnitCells('row', i) });
                  unitConfigs.push({ type: 'col', index: i, cells: getUnitCells('col', i) });
                  unitConfigs.push({ type: 'box', index: i, cells: getUnitCells('box', i) });
              }
          }
      
          for (const unit of unitConfigs) {
              const candidateMap = new Map();
              for (let num = 1; num <= 9; num++) { candidateMap.set(num, []); }
      
              for (const cell of unit.cells) {
                  if (board[cell.row][cell.col].value === 0) {
                      const notes = getNotes(board, cell.row, cell.col);
                      notes.forEach(num => {
                          candidateMap.get(num).push(cell);
                      });
                  }
              }
      
              for (let num = 1; num <= 9; num++) {
                  const possibleCells = candidateMap.get(num);
                  if (possibleCells.length === 1) {
                      const target = possibleCells[0];
                      if (targetCell && (target.row !== targetCell.row || target.col !== targetCell.col)) {
                          continue;
                      }
                      const secondaryCells = unit.cells.filter(c => !(c.row === target.row && c.col === target.col));
                      return {
                          type: 'Hidden Single',
                          primaryCells: [target],
                          secondaryCells: secondaryCells,
                          eliminations: [],
                          solve: { row: target.row, col: target.col, num },
                      };
                  }
              }
          }
          return null;
      };
      
      const findNakedPair = (board, targetCell) => {
          const units = [];
          if (targetCell) {
              const boxIndex = Math.floor(targetCell.row / 3) * 3 + Math.floor(targetCell.col / 3);
              units.push(getUnitCells('row', targetCell.row));
              units.push(getUnitCells('col', targetCell.col));
              units.push(getUnitCells('box', boxIndex));
          } else {
              for(let i=0; i<9; i++) {
                  units.push(getUnitCells('row', i));
                  units.push(getUnitCells('col', i));
                  units.push(getUnitCells('box', i));
              }
          }
      
          for (const unit of units) {
              const cellsWithTwoNotes = unit.filter(cell => getNotes(board, cell.row, cell.col).size === 2);
              if (cellsWithTwoNotes.length < 2) continue;
      
              for (let i = 0; i < cellsWithTwoNotes.length; i++) {
                  for (let j = i + 1; j < cellsWithTwoNotes.length; j++) {
                      const cell1 = cellsWithTwoNotes[i];
                      const cell2 = cellsWithTwoNotes[j];
                      const notes1 = getNotes(board, cell1.row, cell1.col);
                      const notes2 = getNotes(board, cell2.row, cell2.col);
                      const notes1Arr = [...notes1].sort();
                      const notes2Arr = [...notes2].sort();
      
                      if (notes1Arr.length === 2 && notes1Arr[0] === notes2Arr[0] && notes1Arr[1] === notes2Arr[1]) {
                          const pairNums = notes1Arr;
                          const primaryCells = [cell1, cell2];
                          const eliminations = [];
                          const secondaryCells = [];
      
                          for (const unitCell of unit) {
                              if (primaryCells.some(pc => pc.row === unitCell.row && pc.col === unitCell.col)) continue;
                              
                              const unitCellNotes = getNotes(board, unitCell.row, unitCell.col);
                              let madeElimination = false;
                              if (unitCellNotes.has(pairNums[0])) {
                                  eliminations.push({ row: unitCell.row, col: unitCell.col, num: pairNums[0] });
                                  madeElimination = true;
                              }
                              if (unitCellNotes.has(pairNums[1])) {
                                  eliminations.push({ row: unitCell.row, col: unitCell.col, num: pairNums[1] });
                                  madeElimination = true;
                              }
                              if (madeElimination && !secondaryCells.some(sc => sc.row === unitCell.row && sc.col === unitCell.col)) {
                                  secondaryCells.push(unitCell);
                              }
                          }
      
                          if (eliminations.length > 0) {
                              if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                              
                              return {
                                  type: 'Naked Pair',
                                  primaryCells,
                                  secondaryCells,
                                  eliminations,
                                  solve: null,
                              };
                          }
                      }
                  }
              }
          }
          return null;
      };
      
      const findHiddenPair = (board, targetCell) => {
          const units = [];
          if (targetCell) {
              const boxIndex = Math.floor(targetCell.row / 3) * 3 + Math.floor(targetCell.col / 3);
              units.push(getUnitCells('row', targetCell.row));
              units.push(getUnitCells('col', targetCell.col));
              units.push(getUnitCells('box', boxIndex));
          } else {
              for(let i=0; i<9; i++) {
                  units.push(getUnitCells('row', i));
                  units.push(getUnitCells('col', i));
                  units.push(getUnitCells('box', i));
              }
          }
          
          for (const unit of units) {
              const candidateMap = new Map();
              for (let num = 1; num <= 9; num++) { candidateMap.set(num, []); }
      
              for (const cell of unit) {
                  if (board[cell.row][cell.col].value === 0) {
                      getNotes(board, cell.row, cell.col).forEach(num => {
                          candidateMap.get(num).push(cell);
                      });
                  }
              }
      
              const numsInTwoCells = [];
              for (let num = 1; num <= 9; num++) {
                  if (candidateMap.get(num).length === 2) {
                      numsInTwoCells.push(num);
                  }
              }
      
              if (numsInTwoCells.length < 2) continue;
      
              for (let i = 0; i < numsInTwoCells.length; i++) {
                  for (let j = i + 1; j < numsInTwoCells.length; j++) {
                      const num1 = numsInTwoCells[i];
                      const num2 = numsInTwoCells[j];
                      const cells1 = candidateMap.get(num1);
                      const cells2 = candidateMap.get(num2);
      
                      const cells1Ids = cells1.map(c => `${c.row}-${c.col}`).sort();
                      const cells2Ids = cells2.map(c => `${c.row}-${c.col}`).sort();
      
                      if (cells1Ids[0] === cells2Ids[0] && cells1Ids[1] === cells2Ids[1]) {
                          const primaryCells = cells1;
                          if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
      
                          const allNotesInPair = new Set([...getNotes(board, primaryCells[0].row, primaryCells[0].col), ...getNotes(board, primaryCells[1].row, primaryCells[1].col)]);
                          allNotesInPair.delete(num1);
                          allNotesInPair.delete(num2);
      
                          const eliminations = [];
                          allNotesInPair.forEach(note => {
                              eliminations.push({ row: primaryCells[0].row, col: primaryCells[0].col, num: note });
                              eliminations.push({ row: primaryCells[1].row, col: primaryCells[1].col, num: note });
                          });
                          
                          const uniqueElims = eliminations.filter((v,i,a)=>a.findIndex(t=>(t.row === v.row && t.col===v.col && t.num === v.num))===i);
      
                          if (uniqueElims.length > 0) {
                              return {
                                  type: 'Hidden Pair',
                                  primaryCells,
                                  secondaryCells: [],
                                  eliminations: uniqueElims,
                                  solve: null,
                              };
                          }
                      }
                  }
              }
          }
          return null;
      };
      
      const findNakedTriple = (board, targetCell) => {
          const units = [];
          if (targetCell) {
              const boxIndex = Math.floor(targetCell.row / 3) * 3 + Math.floor(targetCell.col / 3);
              units.push(getUnitCells('row', targetCell.row));
              units.push(getUnitCells('col', targetCell.col));
              units.push(getUnitCells('box', boxIndex));
          } else {
              for(let i=0; i<9; i++) {
                  units.push(getUnitCells('row', i));
                  units.push(getUnitCells('col', i));
                  units.push(getUnitCells('box', i));
              }
          }
      
          for (const unit of units) {
              const candidateCells = unit.filter(cell => {
                  const notes = getNotes(board, cell.row, cell.col);
                  return notes.size > 1 && notes.size <= 3;
              });
      
              if (candidateCells.length < 3) continue;
      
              for (let i = 0; i < candidateCells.length; i++) {
                  for (let j = i + 1; j < candidateCells.length; j++) {
                      for (let k = j + 1; k < candidateCells.length; k++) {
                          const c1 = candidateCells[i], c2 = candidateCells[j], c3 = candidateCells[k];
                          const n1 = getNotes(board, c1.row, c1.col), n2 = getNotes(board, c2.row, c2.col), n3 = getNotes(board, c3.row, c3.col);
                          const combinedNotes = new Set([...n1, ...n2, ...n3]);
      
                          if (combinedNotes.size === 3) {
                              const primaryCells = [c1, c2, c3];
                              if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
      
                              const tripleNums = [...combinedNotes];
                              const eliminations = [], secondaryCells = [];
      
                              for (const unitCell of unit) {
                                  if (primaryCells.some(pc => pc.row === unitCell.row && pc.col === unitCell.col)) continue;
                                  
                                  const unitCellNotes = getNotes(board, unitCell.row, unitCell.col);
                                  let madeElimination = false;
                                  for (const num of tripleNums) {
                                      if (unitCellNotes.has(num)) {
                                          eliminations.push({ row: unitCell.row, col: unitCell.col, num });
                                          madeElimination = true;
                                      }
                                  }
                                  if (madeElimination) secondaryCells.push(unitCell);
                              }
      
                              if (eliminations.length > 0) {
                                  const uniqueSecondary = secondaryCells.filter((v,i,a)=>a.findIndex(t=>(t.row === v.row && t.col===v.col))===i);
                                  return {
                                      type: 'Naked Triple',
                                      primaryCells,
                                      secondaryCells: uniqueSecondary,
                                      eliminations,
                                      solve: null,
                                  };
                              }
                          }
                      }
                  }
              }
          }
          return null;
      };
      
      const findHiddenTriple = (board, targetCell) => {
          const units = [];
          if (targetCell) {
              const boxIndex = Math.floor(targetCell.row / 3) * 3 + Math.floor(targetCell.col / 3);
              units.push(getUnitCells('row', targetCell.row));
              units.push(getUnitCells('col', targetCell.col));
              units.push(getUnitCells('box', boxIndex));
          } else {
              for(let i=0; i<9; i++) {
                  units.push(getUnitCells('row', i));
                  units.push(getUnitCells('col', i));
                  units.push(getUnitCells('box', i));
              }
          }
          
          for (const unit of units) {
              const candidateMap = new Map();
              for (let num = 1; num <= 9; num++) { candidateMap.set(num, []); }
      
              for (const cell of unit) {
                  if (board[cell.row][cell.col].value === 0) {
                      getNotes(board, cell.row, cell.col).forEach(num => {
                          candidateMap.get(num).push(cell);
                      });
                  }
              }
      
              const candidateNums = [];
              for (let num = 1; num <= 9; num++) {
                  const cells = candidateMap.get(num);
                  if (cells.length === 2 || cells.length === 3) candidateNums.push(num);
              }
              if (candidateNums.length < 3) continue;
      
              for (let i = 0; i < candidateNums.length; i++) {
                  for (let j = i + 1; j < candidateNums.length; j++) {
                      for (let k = j + 1; k < candidateNums.length; k++) {
                          const num1 = candidateNums[i], num2 = candidateNums[j], num3 = candidateNums[k];
                          const cells1 = candidateMap.get(num1), cells2 = candidateMap.get(num2), cells3 = candidateMap.get(num3);
                          const combinedCells = [...cells1, ...cells2, ...cells3];
                          const uniqueCellIds = new Set(combinedCells.map(c => `${c.row}-${c.col}`));
                          
                          if (uniqueCellIds.size === 3) {
                              const primaryCells = [...uniqueCellIds].map(id => ({ row: parseInt(id.split('-')[0]), col: parseInt(id.split('-')[1]) }));
                              if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                              
                              const tripleNums = new Set([num1, num2, num3]);
                              const eliminations = [];
      
                              for (const cell of primaryCells) {
                                  getNotes(board, cell.row, cell.col).forEach(note => {
                                      if (!tripleNums.has(note)) {
                                          eliminations.push({ row: cell.row, col: cell.col, num: note });
                                      }
                                  });
                              }
      
                              if (eliminations.length > 0) {
                                  return {
                                      type: 'Hidden Triple',
                                      primaryCells,
                                      secondaryCells: [],
                                      eliminations,
                                      solve: null,
                                  };
                              }
                          }
                      }
                  }
              }
          }
          return null;
      };
      
      const findIntersectionRemoval = (board, targetCell) => {
          // Pointing
          for (let boxIndex = 0; boxIndex < 9; boxIndex++) {
              const boxCells = getUnitCells('box', boxIndex);
              for (let num = 1; num <= 9; num++) {
                  const candidateCells = boxCells.filter(cell => getNotes(board, cell.row, cell.col).has(num));
                  if (candidateCells.length < 2) continue;
      
                  const rows = new Set(candidateCells.map(c => c.row));
                  const cols = new Set(candidateCells.map(c => c.col));
      
                  if (rows.size === 1) { // All candidates for num in this box are in the same row
                      const row = rows.values().next().value;
                      const rowCells = getUnitCells('row', row);
                      const eliminations = [];
                      for (const cell of rowCells) {
                          const inBox = Math.floor(cell.row / 3) * 3 + Math.floor(cell.col / 3) === boxIndex;
                          if (!inBox && getNotes(board, cell.row, cell.col).has(num)) {
                              eliminations.push({ row: cell.row, col: cell.col, num });
                          }
                      }
                      if (eliminations.length > 0) {
                          if (targetCell && !candidateCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                          const secondaryCells = eliminations.map(e => ({row: e.row, col: e.col}));
                          return { type: 'Pointing', primaryCells: candidateCells, secondaryCells, eliminations, solve: null };
                      }
                  }
                  if (cols.size === 1) { // All candidates for num in this box are in the same col
                      const col = cols.values().next().value;
                      const colCells = getUnitCells('col', col);
                      const eliminations = [];
                      for (const cell of colCells) {
                          const inBox = Math.floor(cell.row / 3) * 3 + Math.floor(cell.col / 3) === boxIndex;
                          if (!inBox && getNotes(board, cell.row, cell.col).has(num)) {
                              eliminations.push({ row: cell.row, col: cell.col, num });
                          }
                      }
                      if (eliminations.length > 0) {
                          if (targetCell && !candidateCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                          const secondaryCells = eliminations.map(e => ({row: e.row, col: e.col}));
                          return { type: 'Pointing', primaryCells: candidateCells, secondaryCells, eliminations, solve: null };
                      }
                  }
              }
          }
      
          // Claiming
          for (let num = 1; num <= 9; num++) {
              for (let i = 0; i < 9; i++) {
                  // Row Claiming
                  const rowCells = getUnitCells('row', i);
                  const rowCandidates = rowCells.filter(cell => getNotes(board, cell.row, cell.col).has(num));
                  if (rowCandidates.length > 1) {
                      const boxes = new Set(rowCandidates.map(c => Math.floor(c.row/3)*3 + Math.floor(c.col/3)));
                      if (boxes.size === 1) {
                          const boxIndex = boxes.values().next().value;
                          const boxCells = getUnitCells('box', boxIndex);
                          const eliminations = [];
                          for(const cell of boxCells) {
                              if (cell.row !== i && getNotes(board, cell.row, cell.col).has(num)) {
                                  eliminations.push({ row: cell.row, col: cell.col, num });
                              }
                          }
                          if (eliminations.length > 0) {
                               if (targetCell && !rowCandidates.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                               const secondaryCells = eliminations.map(e => ({row: e.row, col: e.col}));
                               return { type: 'Claiming', primaryCells: rowCandidates, secondaryCells, eliminations, solve: null };
                          }
                      }
                  }
      
                  // Col Claiming
                  const colCells = getUnitCells('col', i);
                  const colCandidates = colCells.filter(cell => getNotes(board, cell.row, cell.col).has(num));
                  if (colCandidates.length > 1) {
                      const boxes = new Set(colCandidates.map(c => Math.floor(c.row/3)*3 + Math.floor(c.col/3)));
                      if (boxes.size === 1) {
                          const boxIndex = boxes.values().next().value;
                          const boxCells = getUnitCells('box', boxIndex);
                          const eliminations = [];
                           for(const cell of boxCells) {
                              if (cell.col !== i && getNotes(board, cell.row, cell.col).has(num)) {
                                  eliminations.push({ row: cell.row, col: cell.col, num });
                              }
                          }
                          if (eliminations.length > 0) {
                              if (targetCell && !colCandidates.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                              const secondaryCells = eliminations.map(e => ({row: e.row, col: e.col}));
                              return { type: 'Claiming', primaryCells: colCandidates, secondaryCells, eliminations, solve: null };
                          }
                      }
                  }
              }
          }
          return null;
      };
      
      const findFish = (board, targetCell, size, name) => {
          const getCombinations = (array, size) => {
              const result = [];
              function combination(startIndex, currentCombination) {
                  if (currentCombination.length === size) {
                      result.push(currentCombination);
                      return;
                  }
                  for (let i = startIndex; i < array.length; i++) {
                      combination(i + 1, [...currentCombination, array[i]]);
                  }
              }
              combination(0, []);
              return result;
          }
          for (let num = 1; num <= 9; num++) {
              const rowCandidates = [];
              for (let r = 0; r < 9; r++) {
                  const cols = [];
                  for (let c = 0; c < 9; c++) { if (getNotes(board, r, c).has(num)) { cols.push(c); } }
                  if (cols.length >= 2 && cols.length <= size) { rowCandidates.push({ row: r, cols }); }
              }
              if (rowCandidates.length >= size) {
                  const rowCombinations = getCombinations(rowCandidates, size);
                  for (const combination of rowCombinations) {
                      const combinedCols = new Set(combination.flatMap(c => c.cols));
                      if (combinedCols.size === size) {
                          const primaryCols = [...combinedCols].sort();
                          const primaryRows = combination.map(c => c.row);
                          const primaryCells = [];
                          primaryRows.forEach(r => {
                              primaryCols.forEach(c => {
                                  if (getNotes(board, r, c).has(num)) primaryCells.push({ row: r, col: c });
                              });
                          });
                          if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                          const eliminations = [];
                          for (let r = 0; r < 9; r++) {
                              if (!primaryRows.includes(r)) {
                                  primaryCols.forEach(c => {
                                      if (getNotes(board, r, c).has(num)) eliminations.push({ row: r, col: c, num });
                                  });
                              }
                          }
                          if (eliminations.length > 0) {
                              const secondaryCells = eliminations.map(e => ({ row: e.row, col: e.col }));
                              return { type: name, primaryCells, secondaryCells, eliminations, solve: null };
                          }
                      }
                  }
              }
              const colCandidates = [];
              for (let c = 0; c < 9; c++) {
                  const rows = [];
                  for (let r = 0; r < 9; r++) { if (getNotes(board, r, c).has(num)) { rows.push(r); } }
                  if (rows.length >= 2 && rows.length <= size) { colCandidates.push({ col: c, rows }); }
              }
              if (colCandidates.length >= size) {
                  const colCombinations = getCombinations(colCandidates, size);
                  for (const combination of colCombinations) {
                      const combinedRows = new Set(combination.flatMap(c => c.rows));
                      if (combinedRows.size === size) {
                          const primaryRows = [...combinedRows].sort();
                          const primaryCols = combination.map(c => c.col);
                          const primaryCells = [];
                          primaryCols.forEach(c => {
                              primaryRows.forEach(r => {
                                  if (getNotes(board, r, c).has(num)) primaryCells.push({ row: r, col: c });
                              });
                          });
                          if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                          const eliminations = [];
                          for (let c = 0; c < 9; c++) {
                              if (!primaryCols.includes(c)) {
                                  primaryRows.forEach(r => {
                                      if (getNotes(board, r, c).has(num)) eliminations.push({ row: r, col: c, num });
                                  });
                              }
                          }
                          if (eliminations.length > 0) {
                              const secondaryCells = eliminations.map(e => ({ row: e.row, col: e.col }));
                              return { type: name, primaryCells, secondaryCells, eliminations, solve: null };
                          }
                      }
                  }
              }
          }
          return null;
      }
      
      const findXWing = (board, targetCell) => findFish(board, targetCell, 2, 'X-Wing');
      const findSwordfish = (board, targetCell) => findFish(board, targetCell, 3, 'Swordfish');
      const findJellyfish = (board, targetCell) => findFish(board, targetCell, 4, 'Jellyfish');
      
      const cellsSeeEachOther = (cell1, cell2) => {
          if (cell1.row === cell2.row || cell1.col === cell2.col) return true;
          const box1 = Math.floor(cell1.row / 3) * 3 + Math.floor(cell1.col / 3);
          const box2 = Math.floor(cell2.row / 3) * 3 + Math.floor(cell2.col / 3);
          return box1 === box2;
      };
      
      const findXyWing = (board, targetCell) => {
          const twoNoteCells = [];
          for (let r = 0; r < 9; r++) {
              for (let c = 0; c < 9; c++) {
                  if (getNotes(board, r, c).size === 2) {
                      twoNoteCells.push({ row: r, col: c, notes: [...getNotes(board, r, c)] });
                  }
              }
          }
          if (twoNoteCells.length < 3) return null;
          for (const pivot of twoNoteCells) {
              const [x, y] = pivot.notes;
              const pincers = twoNoteCells.filter(cell => cell !== pivot && cellsSeeEachOther(pivot, cell));
              if (pincers.length < 2) continue;
              const pincerA_candidates = pincers.filter(p => p.notes.includes(x) && !p.notes.includes(y));
              const pincerB_candidates = pincers.filter(p => p.notes.includes(y) && !p.notes.includes(x));
              for (const pincerA of pincerA_candidates) {
                  const z = pincerA.notes.find(n => n !== x);
                  if (!z) continue;
                  for (const pincerB of pincerB_candidates) {
                      if (!pincerB.notes.includes(z)) continue;
                      const primaryCells = [pivot, pincerA, pincerB];
                      if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                      const eliminations = [];
                      const secondaryCells = [];
                      for (let r = 0; r < 9; r++) {
                          for (let c = 0; c < 9; c++) {
                              const currentCell = { row: r, col: c };
                              if (primaryCells.some(pc => pc.row === r && pc.col === c)) continue;
                              if (cellsSeeEachOther(pincerA, currentCell) && cellsSeeEachOther(pincerB, currentCell)) {
                                  if (getNotes(board, r, c).has(z)) {
                                      eliminations.push({ row: r, col: c, num: z });
                                      if (!secondaryCells.some(sc => sc.row === r && sc.col === c)) {
                                          secondaryCells.push({ row: r, col: c });
                                      }
                                  }
                              }
                          }
                      }
                      if (eliminations.length > 0) {
                          return { type: 'XY-Wing', primaryCells, secondaryCells, eliminations, solve: null };
                      }
                  }
              }
          }
          return null;
      };
      
      const findSkyscraper = (board, targetCell) => {
          for (let num = 1; num <= 9; num++) {
              // Row-based Skyscraper
              const rowCandidates = [];
              for (let r = 0; r < 9; r++) {
                  const cellsInRow = [];
                  for (let c = 0; c < 9; c++) { if (getNotes(board, r, c).has(num)) cellsInRow.push({ row: r, col: c }); }
                  if (cellsInRow.length === 2) rowCandidates.push(cellsInRow);
              }
      
              if (rowCandidates.length >= 2) {
                  for (let i = 0; i < rowCandidates.length; i++) {
                      for (let j = i + 1; j < rowCandidates.length; j++) {
                          const r1_cells = rowCandidates[i], r2_cells = rowCandidates[j];
                          const [c1, c2] = [r1_cells[0].col, r1_cells[1].col], [c3, c4] = [r2_cells[0].col, r2_cells[1].col];
                          
                          let roof1, roof2;
                          if (c1 === c3 && c2 !== c4) { roof1 = { row: r1_cells[0].row, col: c2 }; roof2 = { row: r2_cells[0].row, col: c4 }; } 
                          else if (c1 === c4 && c2 !== c3) { roof1 = { row: r1_cells[0].row, col: c2 }; roof2 = { row: r2_cells[0].row, col: c3 }; } 
                          else if (c2 === c3 && c1 !== c4) { roof1 = { row: r1_cells[0].row, col: c1 }; roof2 = { row: r2_cells[0].row, col: c4 }; } 
                          else if (c2 === c4 && c1 !== c3) { roof1 = { row: r1_cells[0].row, col: c1 }; roof2 = { row: r2_cells[0].row, col: c3 }; } 
                          else continue;
      
                          const primaryCells = [...r1_cells, ...r2_cells];
                          const eliminations = [], secondaryCells = [];
                          for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
                              if (primaryCells.some(pc => pc.row === r && pc.col === c)) continue;
                              const currentCell = { row: r, col: c };
                              if (cellsSeeEachOther(currentCell, roof1) && cellsSeeEachOther(currentCell, roof2) && getNotes(board, r, c).has(num)) {
                                  eliminations.push({ row: r, col: c, num });
                                  if (!secondaryCells.some(sc => sc.row === r && sc.col === c)) secondaryCells.push({ row: r, col: c });
                              }
                          }
                          if (eliminations.length > 0) {
                              if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                              return { type: 'Skyscraper', primaryCells, secondaryCells, eliminations, solve: null };
                          }
                      }
                  }
              }
              
              // Column-based Skyscraper
              const colCandidates = [];
              for (let c = 0; c < 9; c++) {
                  const cellsInCol = [];
                  for (let r = 0; r < 9; r++) { if (getNotes(board, r, c).has(num)) cellsInCol.push({ row: r, col: c }); }
                  if (cellsInCol.length === 2) colCandidates.push(cellsInCol);
              }
              
              if (colCandidates.length >= 2) {
                  for (let i = 0; i < colCandidates.length; i++) {
                      for (let j = i + 1; j < colCandidates.length; j++) {
                          const c1_cells = colCandidates[i], c2_cells = colCandidates[j];
                          const [r1, r2] = [c1_cells[0].row, c1_cells[1].row], [r3, r4] = [c2_cells[0].row, c2_cells[1].row];
                          
                          let roof1, roof2;
                          if (r1 === r3 && r2 !== r4) { roof1 = { row: r2, col: c1_cells[0].col }; roof2 = { row: r4, col: c2_cells[0].col }; }
                          else if (r1 === r4 && r2 !== r3) { roof1 = { row: r2, col: c1_cells[0].col }; roof2 = { row: r3, col: c2_cells[0].col }; }
                          else if (r2 === r3 && r1 !== r4) { roof1 = { row: r1, col: c1_cells[0].col }; roof2 = { row: r4, col: c2_cells[0].col }; }
                          else if (r2 === r4 && r1 !== r3) { roof1 = { row: r1, col: c1_cells[0].col }; roof2 = { row: r3, col: c2_cells[0].col }; }
                          else continue;
      
                          const primaryCells = [...c1_cells, ...c2_cells];
                          const eliminations = [], secondaryCells = [];
                          for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
                              if (primaryCells.some(pc => pc.row === r && pc.col === c)) continue;
                              const currentCell = { row: r, col: c };
                              if (cellsSeeEachOther(currentCell, roof1) && cellsSeeEachOther(currentCell, roof2) && getNotes(board, r, c).has(num)) {
                                  eliminations.push({ row: r, col: c, num });
                                  if (!secondaryCells.some(sc => sc.row === r && sc.col === c)) secondaryCells.push({ row: r, col: c });
                              }
                          }
                          if (eliminations.length > 0) {
                              if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                              return { type: 'Skyscraper', primaryCells, secondaryCells, eliminations, solve: null };
                          }
                      }
                  }
              }
          }
          return null;
      };
      
      const findTwoStringKite = (board, targetCell) => {
          const getBox = (r, c) => Math.floor(r / 3) * 3 + Math.floor(c / 3);
          for (let num = 1; num <= 9; num++) {
              const rowsWithTwo = [];
              for (let r = 0; r < 9; r++) {
                  const cols = [];
                  for (let c = 0; c < 9; c++) { if (getNotes(board, r, c).has(num)) cols.push(c); }
                  if (cols.length === 2) rowsWithTwo.push({ r, cols });
              }
              const colsWithTwo = [];
              for (let c = 0; c < 9; c++) {
                  const rows = [];
                  for (let r = 0; r < 9; r++) { if (getNotes(board, r, c).has(num)) rows.push(r); }
                  if (rows.length === 2) colsWithTwo.push({ c, rows });
              }
              if (rowsWithTwo.length < 1 || colsWithTwo.length < 1) continue;
      
              for (const rowUnit of rowsWithTwo) {
                  const r_base = rowUnit.r;
                  const [c1, c2] = rowUnit.cols;
      
                  for (const colUnit of colsWithTwo) {
                      const c_base = colUnit.c;
                      const [r1, r2] = colUnit.rows;
      
                      const processCase = (linkCol, endCol) => {
                          if (c_base === linkCol && (r1 === r_base || r2 === r_base)) {
                              const r_end = (r1 === r_base) ? r2 : r1;
                              const c_end = endCol;
                              
                              const rowEnd = { r: r_base, c: c_end };
                              const colEnd = { r: r_end, c: c_base };
                              if (getBox(rowEnd.r, rowEnd.c) === getBox(colEnd.r, colEnd.c)) {
                                  return null;
                              }
      
                              if (getNotes(board, r_end, c_end).has(num)) {
                                  const primaryCells = [{row: r_base, col: linkCol}, {row: r_base, col: endCol}, {row: r_end, col: linkCol}];
                                  if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) return null;
                                  return { type: 'Two-String Kite', primaryCells, secondaryCells: [{row: r_end, col: c_end}], eliminations: [{ row: r_end, col: c_end, num }], solve: null };
                              }
                          }
                          return null;
                      }
      
                      let hint = processCase(c1, c2);
                      if (hint) return hint;
                      
                      hint = processCase(c2, c1);
                      if (hint) return hint;
                  }
              }
          }
          return null;
      };
      
      const findXyzWing = (board, targetCell) => {
          const threeNoteCells = [], twoNoteCells = [];
          for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
              const notes = getNotes(board, r, c);
              if (notes.size === 3) threeNoteCells.push({ row: r, col: c, notes: [...notes] });
              if (notes.size === 2) twoNoteCells.push({ row: r, col: c, notes: [...notes] });
          }
          if (threeNoteCells.length < 1 || twoNoteCells.length < 2) return null;
      
          for (const pivot of threeNoteCells) {
              const pivotPeers = twoNoteCells.filter(cell => cell !== pivot && cellsSeeEachOther(pivot, cell));
              if (pivotPeers.length < 2) continue;
              for (const pincerA of pivotPeers) for (const pincerB of pivotPeers) {
                  if (pincerA === pincerB || !cellsSeeEachOther(pincerA, pincerB)) continue;
      
                  for (let i = 0; i < 3; i++) {
                      const z = pivot.notes[i];
                      const [x, y] = pivot.notes.filter(n => n !== z);
                      const notesA = new Set(pincerA.notes), notesB = new Set(pincerB.notes);
                      let found = false;
                      if ((notesA.has(x) && notesA.has(z) && notesB.has(y) && notesB.has(z)) || (notesA.has(y) && notesA.has(z) && notesB.has(x) && notesB.has(z))) {
                          found = true;
                      }
                      if (found) {
                          const primaryCells = [pivot, pincerA, pincerB];
                          if (targetCell && !primaryCells.some(pc => pc.row === targetCell.row && pc.col === targetCell.col)) continue;
                          const eliminations = [], secondaryCells = [];
                          for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
                              if (primaryCells.some(pc => pc.row === r && pc.col === c)) continue;
                              const currentCell = { row: r, col: c };
                              if (cellsSeeEachOther(currentCell, pivot) && cellsSeeEachOther(currentCell, pincerA) && cellsSeeEachOther(currentCell, pincerB)) {
                                  if (getNotes(board, r, c).has(z)) {
                                      eliminations.push({ row: r, col: c, num: z });
                                      if (!secondaryCells.some(sc => sc.row === r && sc.col === c)) secondaryCells.push({ row: r, col: c });
                                  }
                              }
                          }
                          if (eliminations.length > 0) return { type: 'XYZ-Wing', primaryCells, secondaryCells, eliminations, solve: null };
                      }
                  }
              }
          }
          return null;
      };
      
      const findUniqueRectangle = (board, targetCell) => {
          // Type 1
          for (let r1 = 0; r1 < 9; r1++) for (let r2 = r1 + 1; r2 < 9; r2++) {
              for (let c1 = 0; c1 < 9; c1++) for (let c2 = c1 + 1; c2 < 9; c2++) {
                  const corners = [
                      { row: r1, col: c1, notes: getNotes(board, r1, c1) }, { row: r1, col: c2, notes: getNotes(board, r1, c2) },
                      { row: r2, col: c1, notes: getNotes(board, r2, c1) }, { row: r2, col: c2, notes: getNotes(board, r2, c2) },
                  ];
                  const bivalueCorners = corners.filter(c => c.notes.size === 2);
                  if (bivalueCorners.length !== 3) continue;
      
                  const notesStr = [...bivalueCorners[0].notes].sort().join('');
                  if ([...bivalueCorners[1].notes].sort().join('') !== notesStr || [...bivalueCorners[2].notes].sort().join('') !== notesStr) continue;
      
                  const targetCorner = corners.find(c => !bivalueCorners.includes(c));
                  if (!targetCorner) continue;
      
                  const candidates = [...bivalueCorners[0].notes];
                  if (targetCorner.notes.has(candidates[0]) && targetCorner.notes.has(candidates[1])) {
                      const primaryCells = bivalueCorners.map(c => ({ row: c.row, col: c.col }));
                      if (targetCell && !(targetCell.row === targetCorner.row && targetCell.col === targetCorner.col)) continue;
                      return {
                          type: 'Unique Rectangle', primaryCells, secondaryCells: [{ row: targetCorner.row, col: targetCorner.col }],
                          eliminations: candidates.map(num => ({ row: targetCorner.row, col: targetCorner.col, num })), solve: null,
                      };
                  }
              }
          }
          return null;
      }
      
      const findHint = (board, difficulty, targetCell, technique = null) => {
          const findFunctions = {
              nakedSingle: () => findNakedSingle(board, targetCell),
              hiddenSingle: () => findHiddenSingle(board, targetCell),
              nakedPair: () => findNakedPair(board, targetCell),
              hiddenPair: () => findHiddenPair(board, targetCell),
              nakedTriple: () => findNakedTriple(board, targetCell),
              hiddenTriple: () => findHiddenTriple(board, targetCell),
              intersectionRemoval: () => findIntersectionRemoval(board, targetCell),
              xWing: () => findXWing(board, targetCell),
              swordfish: () => findSwordfish(board, targetCell),
              xyWing: () => findXyWing(board, targetCell),
              jellyfish: () => findJellyfish(board, targetCell),
              skyscraper: () => findSkyscraper(board, targetCell),
              twoStringKite: () => findTwoStringKite(board, targetCell),
              xyzWing: () => findXyzWing(board, targetCell),
              uniqueRectangle: () => findUniqueRectangle(board, targetCell),
          };
          
          if (technique && findFunctions[technique]) {
              return findFunctions[technique]();
          }
          
          const techniquesByDifficulty = {
              easy: ['nakedSingle', 'hiddenSingle'],
              medium: ['nakedSingle', 'hiddenSingle'],
              hard: ['nakedSingle', 'hiddenSingle', 'nakedPair', 'hiddenPair', 'nakedTriple', 'hiddenTriple'],
              professional: ['nakedSingle', 'hiddenSingle', 'nakedPair', 'hiddenPair', 'nakedTriple', 'hiddenTriple', 'intersectionRemoval', 'xWing', 'skyscraper', 'twoStringKite', 'xyWing', 'xyzWing', 'swordfish', 'jellyfish', 'uniqueRectangle'],
          };
      
          const techniquesToTry = techniquesByDifficulty[difficulty] || techniquesByDifficulty.professional;
      
          for (const techName of techniquesToTry) {
              const hint = findFunctions[techName]();
              if (hint) {
                  // A hint is valid if it either solves a cell or provides any valid eliminations.
                  // The original check for "actionable" eliminations was too restrictive and could fail
                  // if auto-notes became stale, causing inconsistencies across devices.
                  // A logically sound elimination is always a useful hint.
                  if (hint.solve || (hint.eliminations && hint.eliminations.length > 0)) {
                      return hint;
                  }
              }
          }
      
          return null;
      };

      // --- services/sudokuGenerator.ts ---
      
      const shuffle = (array) => {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      };
      
      const isSafe = (grid, row, col, num) => {
        for (let x = 0; x < 9; x++) {
          if (grid[row][x] === num) return false;
        }
        for (let x = 0; x < 9; x++) {
          if (grid[x][col] === num) return false;
        }
        const startRow = row - (row % 3);
        const startCol = col - (col % 3);
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (grid[i + startRow][j + startCol] === num) return false;
          }
        }
        return true;
      };
      
      const solveGrid = (grid) => {
        for (let row = 0; row < 9; row++) {
          for (let col = 0; col < 9; col++) {
            if (grid[row][col] === 0) {
              const numbers = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
              for (const num of numbers) {
                if (isSafe(grid, row, col, num)) {
                  grid[row][col] = num;
                  if (solveGrid(grid)) return true;
                  grid[row][col] = 0;
                }
              }
              return false;
            }
          }
        }
        return true;
      };
      
      const countSolutions = (grid) => {
        let count = 0;
        function solve() {
          if (count > 1) return;
      
          for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
              if (grid[r][c] === 0) {
                for (let num = 1; num <= 9; num++) {
                  if (isSafe(grid, r, c, num)) {
                    grid[r][c] = num;
                    solve();
                    grid[r][c] = 0; // Backtrack
                  }
                }
                return;
              }
            }
          }
          count++;
        }
        solve();
        return count;
      };
      
      const REMOVAL_COUNT = {
        easy: 40,
        medium: 48,
        hard: 54,
        professional: 62,
      };
      
      const DIFFICULTY_SCORES = {
        easy: { min: 45, max: 60 },
        medium: { min: 61, max: 120 },
        hard: { min: 121, max: 499 },
        professional: { min: 500, max: 9998, minEliteMoves: 4 },
      };
      
      const ratePuzzleDifficulty = (puzzle) => {
          let board = puzzle.map(row =>
            row.map(value => ({
              value,
              userNotes: new Set(),
              autoNotes: new Set(),
              eliminatedNotes: new Set(),
            }))
          );
          
          const techniqueScores = {
              nakedSingle: 1,
              hiddenSingle: 2,
              nakedPair: 5,
              hiddenPair: 8,
              nakedTriple: 10,
              hiddenTriple: 12,
              intersectionRemoval: 15,
              xWing: 100,
              skyscraper: 110,
              twoStringKite: 120,
              xyWing: 150,
              xyzWing: 180,
              swordfish: 200,
              jellyfish: 250,
              uniqueRectangle: 250,
          };
          
          const eliteTechniques = new Set([
            'xWing', 'skyscraper', 'twoStringKite', 'xyWing', 'xyzWing', 'swordfish', 'jellyfish', 'uniqueRectangle'
          ]);
          
          const orderedTechniques = [
              'nakedSingle', 'hiddenSingle', 'nakedPair', 'hiddenPair', 
              'nakedTriple', 'hiddenTriple', 'intersectionRemoval', 'xWing', 
              'skyscraper', 'twoStringKite', 'xyWing', 'xyzWing', 'swordfish', 
              'jellyfish', 'uniqueRectangle'
          ];
      
          let totalScore = 0;
          let eliteMovesCount = 0;
          let stuck = false;
      
          while (!stuck) {
              let moveMade = false;
              
              for (const techniqueId of orderedTechniques) {
                  const hint = findHint(board, 'professional', null, techniqueId);
                  if (hint) {
                      totalScore += techniqueScores[techniqueId] || 0;
                      if (eliteTechniques.has(techniqueId)) {
                          eliteMovesCount++;
                      }
      
                      if (hint.solve) {
                          const { row, col, num } = hint.solve;
                          board[row][col].value = num;
                          board[row][col].userNotes.clear();
                          board[row][col].autoNotes.clear();
                          board[row][col].eliminatedNotes.clear();
                      } else if (hint.eliminations.length > 0) {
                          hint.eliminations.forEach(({ row, col, num }) => {
                              board[row][col].eliminatedNotes.add(num);
                          });
                      }
                      moveMade = true;
                      break;
                  }
              }
              
              if (!moveMade) {
                  stuck = true;
              }
          }
          
          const isSolved = board.every(row => row.every(cell => cell.value !== 0));
          return isSolved ? { score: totalScore, eliteMoves: eliteMovesCount } : { score: 9999, eliteMoves: 0 };
      };
      
      const generateSudoku = (difficulty = 'medium') => {
        let puzzle, solution;
        const targetDifficulty = DIFFICULTY_SCORES[difficulty];
      
        do {
          solution = Array(9).fill(0).map(() => Array(9).fill(0));
          solveGrid(solution);
          const candidatePuzzle = solution.map(row => [...row]);
          const cells = [];
          for (let r = 0; r < 9; r++) { for (let c = 0; c < 9; c++) { cells.push({ r, c }); } }
          shuffle(cells);
          let removedCount = 0;
          const cellsToRemove = REMOVAL_COUNT[difficulty] ?? 48;
          for (const cell of cells) {
            if (removedCount >= cellsToRemove) { break; }
            const { r, c } = cell;
            const backup = candidatePuzzle[r][c];
            candidatePuzzle[r][c] = 0;
            const puzzleCopy = candidatePuzzle.map(row => [...row]);
            if (countSolutions(puzzleCopy) !== 1) {
              candidatePuzzle[r][c] = backup;
            } else {
              removedCount++;
            }
          }
          const { score: puzzleScore, eliteMoves: puzzleEliteMoves } = ratePuzzleDifficulty(candidatePuzzle);
      
          if (
            puzzleScore >= targetDifficulty.min && 
            puzzleScore <= targetDifficulty.max &&
            (!targetDifficulty.minEliteMoves || puzzleEliteMoves >= targetDifficulty.minEliteMoves)
          ) {
            puzzle = candidatePuzzle;
          }
        } while (!puzzle);
      
        return { puzzle, solution };
      };

      // --- components/themes.ts ---
      
      const themes = {
        default: {
          name: "Default",
          gradientColors: ['#0f172a', '#38bdf8', '#94a3b8', '#eef1f5'],
          light: { "--color-page-bg": "#eef1f5", "--color-text-primary": "#1f2937", "--color-text-secondary": "#6b7280", "--color-text-initial": "#1f2937", "--color-text-user": "#0284c7", "--color-text-wrong": "#dc2626", "--color-text-note": "#6b7280", "--color-text-user-note": "#0ea5e9", "--color-accent": "#0ea5e9", "--color-accent-hover": "#0284c7", "--color-accent-text": "#ffffff", "--color-accent-glow": "rgba(59,130,246,0.7)", "--color-ui-bg": "#ffffff", "--color-ui-bg-secondary": "#f3f4f6", "--color-ui-bg-hover": "rgba(209,213,219,0.8)", "--color-ui-bg-translucent": "rgba(255,255,255,0.9)", "--color-ui-border": "#e5e7eb", "--color-btn-secondary-bg": "#e5e7eb", "--color-btn-secondary-bg-hover": "#d1d5db", "--color-toggle-bg": "#e5e7eb", "--color-board-border-outer": "#9ca3af", "--color-board-border-thick": "#6b7280", "--color-board-border-thin": "#d1d5db", "--color-cell-bg": "#ffffff", "--color-cell-peer-bg": "#f3f4f6", "--color-cell-selected-bg": "#bae6fd", "--color-cell-highlighted-bg": "#e0f2fe", "--color-cell-hover-bg": "#f0f9ff", "--color-note-highlighted-bg": "#bfdbfe", "--color-note-highlighted-text": "#1e40af", "--color-hint-primary-bg": "rgba(252, 211, 77, 0.8)", "--color-hint-secondary-bg": "rgba(252, 211, 77, 0.5)", "--color-hint-text": "#4b5563", "--color-hint-note-text": "#4b5563", "--color-hint-note-text-on-highlight": "#1f2937", "--color-hint-icon": "#f59e0b", "--color-numpad-bg": "#1f2937", "--color-numpad-notes-bg": "#374151", "--color-numpad-text": "#e5e7eb", "--color-numpad-hover-bg": "rgba(55,65,81,0.8)", "--color-controls-bg": "#1f2937", "--color-controls-bg-hover": "rgba(31,41,55,0.8)", "--color-controls-text": "#d1d5db", "--color-controls-hover-bg": "rgba(75,85,99,0.8)", "--color-timer-bg": "#e5e7eb", "--color-timer-text": "#4b5563", "--color-victory-bg": "rgba(186, 230, 253, 0.65)", "--color-victory-title": "#1e293b", "--color-victory-stat-label": "#475569", "--color-victory-stat-value": "#0f172a", },
          dark: { "--color-page-bg": "#0f172a", "--color-text-primary": "#f1f5f9", "--color-text-secondary": "#94a3b8", "--color-text-initial": "#f1f5f9", "--color-text-user": "#38bdf8", "--color-text-wrong": "#f87171", "--color-text-note": "#64748b", "--color-text-user-note": "#7dd3fc", "--color-accent": "#38bdf8", "--color-accent-hover": "#0ea5e9", "--color-accent-text": "#ffffff", "--color-accent-glow": "rgba(59,130,246,0.7)", "--color-ui-bg": "#1e293b", "--color-ui-bg-secondary": "#334155", "--color-ui-bg-hover": "rgba(51, 65, 85, 0.8)", "--color-ui-bg-translucent": "rgba(30,41,59,0.9)", "--color-ui-border": "#334155", "--color-btn-secondary-bg": "#475569", "--color-btn-secondary-bg-hover": "#525f76", "--color-toggle-bg": "#475569", "--color-board-border-outer": "#475569", "--color-board-border-thick": "#64748b", "--color-board-border-thin": "rgba(51, 65, 85, 0.65)", "--color-cell-bg": "#1e293b", "--color-cell-peer-bg": "#334155", "--color-cell-selected-bg": "#075985", "--color-cell-highlighted-bg": "rgba(2,132,199,0.5)", "--color-cell-hover-bg": "rgba(7,89,133,0.5)", "--color-note-highlighted-bg": "rgba(14,165,233,0.6)", "--color-note-highlighted-text": "#ffffff", "--color-hint-primary-bg": "rgba(251, 191, 36, 0.6)", "--color-hint-secondary-bg": "rgba(251, 191, 36, 0.3)", "--color-hint-text": "#fbbf24", "--color-hint-note-text": "#f1f5f9", "--color-hint-note-text-on-highlight": "#f1f5f9", "--color-hint-icon": "#fbbf24", "--color-numpad-bg": "#334155", "--color-numpad-notes-bg": "#475569", "--color-numpad-text": "#cbd5e1", "--color-numpad-hover-bg": "rgba(71,85,105,0.8)", "--color-controls-bg": "#334155", "--color-controls-bg-hover": "rgba(51,65,85,0.8)", "--color-controls-text": "#cbd5e1", "--color-controls-hover-bg": "rgba(71,85,105,0.8)", "--color-timer-bg": "#1e293b", "--color-timer-text": "#94a3b8", "--color-victory-bg": "rgba(30,41,59,0.8)", "--color-victory-title": "#f8fafc", "--color-victory-stat-label": "#94a3b8", "--color-victory-stat-value": "#ffffff", },
        },
        minguo: { name: "Minguo", gradientColors: ['#4a342c', '#c73e38', '#E7A859', '#fdf6f2'], light: {"--color-page-bg":"#fdf6f2","--color-text-primary":"#4a342c","--color-text-secondary":"#8c6d62","--color-text-initial":"#4a342c","--color-text-user":"#c73e38","--color-text-wrong":"#d9534f","--color-text-note":"#a38d85","--color-text-user-note":"#d3913d","--color-accent":"#c73e38","--color-accent-hover":"#b0322d","--color-accent-text":"#ffffff","--color-accent-glow":"rgba(199,62,56,0.7)","--color-ui-bg":"#f9f0ea","--color-ui-bg-secondary":"#f5e9e2","--color-ui-bg-hover":"#e3d5ce","--color-ui-bg-translucent":"rgba(249,240,234,0.9)","--color-ui-border":"#e3d5ce","--color-btn-secondary-bg":"#f0e2d9","--color-btn-secondary-bg-hover":"#e3d5ce","--color-toggle-bg":"#f0e2d9","--color-board-border-outer":"#d3b8ab","--color-board-border-thick":"#BA160C","--color-board-border-thin":"#e3d5ce","--color-cell-bg":"#ffffff","--color-cell-peer-bg":"#f5e9e2","--color-cell-selected-bg":"#fce0d3","--color-cell-highlighted-bg":"#ffeadd","--color-cell-hover-bg":"#fff5f0","--color-note-highlighted-bg":"#ffd3b8","--color-note-highlighted-text":"#7a4023","--color-hint-primary-bg":"rgba(224, 158, 77, 0.8)","--color-hint-secondary-bg":"rgba(224, 158, 77, 0.5)","--color-hint-text":"#7a4023","--color-hint-note-text":"#7a4023","--color-hint-note-text-on-highlight":"#4a342c","--color-hint-icon":"#E7A859","--color-numpad-bg":"#4a342c","--color-numpad-notes-bg":"#7a5a4d","--color-numpad-text":"#f2e8e0","--color-numpad-hover-bg":"rgba(122,90,77,0.8)","--color-controls-bg":"#4a342c","--color-controls-bg-hover":"rgba(74,52,44,0.8)","--color-controls-text":"#f0e2d9","--color-controls-hover-bg":"rgba(122,90,77,0.8)","--color-timer-bg":"#f0e2d9","--color-timer-text":"#7a5a4d","--color-victory-bg":"rgba(245, 233, 226, 0.8)","--color-victory-title":"#4a342c","--color-victory-stat-label":"#7a5a4d","--color-victory-stat-value":"#c73e38"}, dark: {"--color-page-bg":"#201512","--color-text-primary":"#f2e8e0","--color-text-secondary":"#a38d85","--color-text-initial":"#f2e8e0","--color-text-user":"#E7A859","--color-text-wrong":"#d9534f","--color-text-note":"#8c6d62","--color-text-user-note":"#E7A859","--color-accent":"#BA160C","--color-accent-hover":"#a0130a","--color-accent-text":"#ffffff","--color-accent-glow":"rgba(186,22,12,0.7)","--color-ui-bg":"#31231f","--color-ui-bg-secondary":"#4a342c","--color-ui-bg-hover":"rgba(74,52,44,0.8)","--color-ui-bg-translucent":"rgba(49,35,31,0.9)","--color-ui-border":"#4a342c","--color-btn-secondary-bg":"#5e453c","--color-btn-secondary-bg-hover":"#7a5a4d","--color-toggle-bg":"#5e453c","--color-board-border-outer":"#4a342c","--color-board-border-thick":"#BA160C","--color-board-border-thin":"rgba(74,52,44,0.65)","--color-cell-bg":"#31231f","--color-cell-peer-bg":"#4a342c","--color-cell-selected-bg":"#5e453c","--color-cell-highlighted-bg":"rgba(231,168,89,0.3)","--color-cell-hover-bg":"rgba(122,90,77,0.3)","--color-note-highlighted-bg":"rgba(231,168,89,0.5)","--color-note-highlighted-text":"#ffffff","--color-hint-primary-bg":"rgba(231,168,89,0.6)","--color-hint-secondary-bg":"rgba(231,168,89,0.3)","--color-hint-text":"#E7A859","--color-hint-note-text":"#f2e8e0","--color-hint-note-text-on-highlight":"#31231f","--color-hint-icon":"#E7A859","--color-numpad-bg":"#4a342c","--color-numpad-notes-bg":"#5e453c","--color-numpad-text":"#f2e8e0","--color-numpad-hover-bg":"rgba(122,90,77,0.8)","--color-controls-bg":"#4a342c","--color-controls-bg-hover":"rgba(94,69,60,0.8)","--color-controls-text":"#f2e8e0","--color-controls-hover-bg":"rgba(122,90,77,0.8)","--color-timer-bg":"#31231f","--color-timer-text":"#a38d85","--color-victory-bg":"rgba(49,35,31,0.8)","--color-victory-title":"#f2e8e0","--color-victory-stat-label":"#a38d85","--color-victory-stat-value":"#E7A859"} },
        forest: { name: "Forest", gradientColors: ['#2a3128', '#C19C6F', '#626d56', '#e8ebe5'], light: {"--color-page-bg":"#f5f6f4","--color-text-primary":"#404936","--color-text-secondary":"#7d8478","--color-text-initial":"#404936","--color-text-user":"#8a6d4d","--color-text-wrong":"#c75c5c","--color-text-note":"#9ca198","--color-text-user-note":"#7d5e3c","--color-accent":"#C19C6F","--color-accent-hover":"#a7855a","--color-accent-text":"#ffffff","--color-accent-glow":"rgba(193,156,111,0.7)","--color-ui-bg":"#e8ebe5","--color-ui-bg-secondary":"#dcdfda","--color-ui-bg-hover":"#c8cec5","--color-ui-bg-translucent":"rgba(232,235,229,0.9)","--color-ui-border":"#c8cec5","--color-btn-secondary-bg":"#dcdfda","--color-btn-secondary-bg-hover":"#c8cec5","--color-toggle-bg":"#dcdfda","--color-board-border-outer":"#b8beb4","--color-board-border-thick":"#99744A","--color-board-border-thin":"#c8cec5","--color-cell-bg":"#ffffff","--color-cell-peer-bg":"#e8ebe5","--color-cell-selected-bg":"#f5eadd","--color-cell-highlighted-bg":"#f9f2e8","--color-cell-hover-bg":"#faf6f0","--color-note-highlighted-bg":"#e3d3bf","--color-note-highlighted-text":"#7d5e3c","--color-hint-primary-bg":"rgba(193,156,111, 0.8)","--color-hint-secondary-bg":"rgba(193,156,111, 0.5)","--color-hint-text":"#8a6d4d","--color-hint-note-text":"#404936","--color-hint-note-text-on-highlight":"#404936","--color-hint-icon":"#C19C6F","--color-numpad-bg":"#404936","--color-numpad-notes-bg":"#626d56","--color-numpad-text":"#e8e6e1","--color-numpad-hover-bg":"rgba(98,109,86,0.8)","--color-controls-bg":"#404936","--color-controls-bg-hover":"rgba(64,73,54,0.8)","--color-controls-text":"#e8e6e1","--color-controls-hover-bg":"rgba(98,109,86,0.8)","--color-timer-bg":"#dcdfda","--color-timer-text":"#626d56","--color-victory-bg":"rgba(232,235,229,0.8)","--color-victory-title":"#404936","--color-victory-stat-label":"#7d8478","--color-victory-stat-value":"#8a6d4d"}, dark: {"--color-page-bg":"#2a3128","--color-text-primary":"#e8e6e1","--color-text-secondary":"#9ca198","--color-text-initial":"#e8e6e1","--color-text-user":"#c7b299","--color-text-wrong":"#d97474","--color-text-note":"#7d8478","--color-text-user-note":"#C19C6F","--color-accent":"#99744A","--color-accent-hover":"#805f3a","--color-accent-text":"#ffffff","--color-accent-glow":"rgba(153,116,74,0.7)","--color-ui-bg":"#3d473a","--color-ui-bg-secondary":"#404936","--color-ui-bg-hover":"rgba(64,73,54,0.8)","--color-ui-bg-translucent":"rgba(61,71,58,0.9)","--color-ui-border":"#404936","--color-btn-secondary-bg":"#626d56","--color-btn-secondary-bg-hover":"#7d8478","--color-toggle-bg":"#626d56","--color-board-border-outer":"#626d56","--color-board-border-thick":"#99744A","--color-board-border-thin":"#626d56","--color-cell-bg":"#3d473a","--color-cell-peer-bg":"#404936","--color-cell-selected-bg":"#626d56","--color-cell-highlighted-bg":"rgba(199,178,153,0.3)","--color-cell-hover-bg":"rgba(125,132,120,0.3)","--color-note-highlighted-bg":"rgba(193,156,111,0.5)","--color-note-highlighted-text":"#ffffff","--color-hint-primary-bg":"rgba(193,156,111,0.6)","--color-hint-secondary-bg":"rgba(193,156,111,0.3)","--color-hint-text":"#C19C6F","--color-hint-note-text":"#e8e6e1","--color-hint-note-text-on-highlight":"#e8e6e1","--color-hint-icon":"#C19C6F","--color-numpad-bg":"#404936","--color-numpad-notes-bg":"#626d56","--color-numpad-text":"#e8e6e1","--color-numpad-hover-bg":"rgba(125,132,120,0.8)","--color-controls-bg":"#404936","--color-controls-bg-hover":"rgba(98,109,86,0.8)","--color-controls-text":"#e8e6e1","--color-controls-hover-bg":"rgba(125,132,120,0.8)","--color-timer-bg":"#2a3128","--color-timer-text":"#9ca198","--color-victory-bg":"rgba(61,71,58,0.8)","--color-victory-title":"#e8e6e1","--color-victory-stat-label":"#9ca198","--color-victory-stat-value":"#c7b299"} },
        luxury: { name: "Luxury", gradientColors: ['#121212', '#ffdb89', '#888888', '#f0f0f0'], light: {"--color-page-bg":"#f0f0f0","--color-text-primary":"#121212","--color-text-secondary":"#555555","--color-text-initial":"#121212","--color-text-user":"#c79f40","--color-text-wrong":"#ad0013","--color-text-note":"#777777","--color-text-user-note":"#a68436","--color-accent":"#c79f40","--color-accent-hover":"#a68436","--color-accent-text":"#ffffff","--color-accent-glow":"rgba(199,159,64,0.7)","--color-ui-bg":"#ffffff","--color-ui-bg-secondary":"#e8e8e8","--color-ui-bg-hover":"#dcdcdc","--color-ui-bg-translucent":"rgba(255,255,255,0.9)","--color-ui-border":"#dcdcdc","--color-btn-secondary-bg":"#e8e8e8","--color-btn-secondary-bg-hover":"#dcdcdc","--color-toggle-bg":"#e8e8e8","--color-board-border-outer":"#cccccc","--color-board-border-thick":"#333333","--color-board-border-thin":"#dcdcdc","--color-cell-bg":"#ffffff","--color-cell-peer-bg":"#e8e8e8","--color-cell-selected-bg":"#fff5d6","--color-cell-highlighted-bg":"#fff9e3","--color-cell-hover-bg":"#fffcf2","--color-note-highlighted-bg":"#ffe8ac","--color-note-highlighted-text":"#8c6e2a","--color-hint-primary-bg":"rgba(255,219,137,0.8)","--color-hint-secondary-bg":"rgba(255,219,137,0.5)","--color-hint-text":"#8c6e2a","--color-hint-note-text":"#121212","--color-hint-note-text-on-highlight":"#121212","--color-hint-icon":"#c79f40","--color-numpad-bg":"#2c2c2e","--color-numpad-notes-bg":"#444446","--color-numpad-text":"#e1e1e1","--color-numpad-hover-bg":"rgba(68,68,70,0.8)","--color-controls-bg":"#2c2c2e","--color-controls-bg-hover":"rgba(44,44,46,0.8)","--color-controls-text":"#e1e1e1","--color-controls-hover-bg":"rgba(68,68,70,0.8)","--color-timer-bg":"#e8e8e8","--color-timer-text":"#555555","--color-victory-bg":"rgba(232,232,232,0.8)","--color-victory-title":"#121212","--color-victory-stat-label":"#555555","--color-victory-stat-value":"#c79f40"}, dark: {"--color-page-bg":"#121212","--color-text-primary":"#e1e1e1","--color-text-secondary":"#888888","--color-text-initial":"#e1e1e1","--color-text-user":"#ffdb89","--color-text-wrong":"#ff5566","--color-text-note":"#666666","--color-text-user-note":"#ffdb89","--color-accent":"#ffdb89","--color-accent-hover":"#f0c76e","--color-accent-text":"#000000","--color-accent-glow":"rgba(255,219,137,0.7)","--color-ui-bg":"#1f1f1f","--color-ui-bg-secondary":"#2c2c2e","--color-ui-bg-hover":"rgba(44,44,46,0.8)","--color-ui-bg-translucent":"rgba(31,31,31,0.9)","--color-ui-border":"#2c2c2e","--color-btn-secondary-bg":"#3a3a3c","--color-btn-secondary-bg-hover":"#444446","--color-toggle-bg":"#3a3a3c","--color-board-border-outer":"#3a3a3c","--color-board-border-thick":"#888888","--color-board-border-thin":"#3a3a3c","--color-cell-bg":"#1f1f1f","--color-cell-peer-bg":"#2c2c2e","--color-cell-selected-bg":"#444446","--color-cell-highlighted-bg":"rgba(255,219,137,0.2)","--color-cell-hover-bg":"rgba(255,219,137,0.1)","--color-note-highlighted-bg":"rgba(255,219,137,0.4)","--color-note-highlighted-text":"#121212","--color-hint-primary-bg":"rgba(255,219,137,0.5)","--color-hint-secondary-bg":"rgba(255,219,137,0.25)","--color-hint-text":"#ffdb89","--color-hint-note-text":"#e1e1e1","--color-hint-note-text-on-highlight":"#121212","--color-hint-icon":"#ffdb89","--color-numpad-bg":"#2c2c2e","--color-numpad-notes-bg":"#3a3a3c","--color-numpad-text":"#e1e1e1","--color-numpad-hover-bg":"rgba(68,68,70,0.8)","--color-controls-bg":"#2c2c2e","--color-controls-bg-hover":"rgba(58,58,60,0.8)","--color-controls-text":"#e1e1e1","--color-controls-hover-bg":"rgba(68,68,70,0.8)","--color-timer-bg":"#1f1f1f","--color-timer-text":"#888888","--color-victory-bg":"rgba(31,31,31,0.8)","--color-victory-title":"#e1e1e1","--color-victory-stat-label":"#888888","--color-victory-stat-value":"#ffdb89"} },
        retro: { name: "Retro", gradientColors: ['#1e3a5f', '#D12128', '#f3d999', '#eaf0f6'], light: {"--color-page-bg":"#eaf0f6","--color-text-primary":"#012a40","--color-text-secondary":"#4a6a82","--color-text-initial":"#012a40","--color-text-user":"#01344F","--color-text-wrong":"#D12128","--color-text-note":"#6b879c","--color-text-user-note":"#014c73","--color-accent":"#D12128","--color-accent-hover":"#b31b21","--color-accent-text":"#ffffff","--color-accent-glow":"rgba(209,33,40,0.7)","--color-ui-bg":"#ffffff","--color-ui-bg-secondary":"#d8e1e9","--color-ui-bg-hover":"#c6d2dd","--color-ui-bg-translucent":"rgba(255,255,255,0.9)","--color-ui-border":"#c6d2dd","--color-btn-secondary-bg":"#d8e1e9","--color-btn-secondary-bg-hover":"#c6d2dd","--color-toggle-bg":"#d8e1e9","--color-board-border-outer":"#a3b6c5","--color-board-border-thick":"#01344F","--color-board-border-thin":"#c6d2dd","--color-cell-bg":"#ffffff","--color-cell-peer-bg":"#d8e1e9","--color-cell-selected-bg":"#fce0e1","--color-cell-highlighted-bg":"#f9f2e3","--color-cell-hover-bg":"#fffcf2","--color-note-highlighted-bg":"#fde8a7","--color-note-highlighted-text":"#6c5b2a","--color-hint-primary-bg":"rgba(250,227,172,0.8)","--color-hint-secondary-bg":"rgba(250,227,172,0.5)","--color-hint-text":"#6c5b2a","--color-hint-note-text":"#012a40","--color-hint-note-text-on-highlight":"#012a40","--color-hint-icon":"#FAE3AC","--color-numpad-bg":"#01344F","--color-numpad-notes-bg":"#014c73","--color-numpad-text":"#f0eadd","--color-numpad-hover-bg":"rgba(1,76,115,0.8)","--color-controls-bg":"#01344F","--color-controls-bg-hover":"rgba(1,42,64,0.8)","--color-controls-text":"#f0eadd","--color-controls-hover-bg":"rgba(1,76,115,0.8)","--color-timer-bg":"#d8e1e9","--color-timer-text":"#4a6a82","--color-victory-bg":"rgba(216,225,233,0.8)","--color-victory-title":"#012a40","--color-victory-stat-label":"#4a6a82","--color-victory-stat-value":"#D12128"}, dark: {"--color-page-bg":"#1e3a5f","--color-text-primary":"#f0eadd","--color-text-secondary":"#a3b6c5","--color-text-initial":"#f0eadd","--color-text-user":"#f3d999","--color-text-wrong":"#e54b4b","--color-text-note":"#6b879c","--color-text-user-note":"#f3d999","--color-accent":"#D12128","--color-accent-hover":"#b31b21","--color-accent-text":"#ffffff","--color-accent-glow":"rgba(209,33,40,0.7)","--color-ui-bg":"#01344F","--color-ui-bg-secondary":"#012a40","--color-ui-bg-hover":"rgba(1,42,64,0.8)","--color-ui-bg-translucent":"rgba(1,52,79,0.9)","--color-ui-border":"#012a40","--color-btn-secondary-bg":"#2a4c78","--color-btn-secondary-bg-hover":"#4a6a82","--color-toggle-bg":"#2a4c78","--color-board-border-outer":"#2a4c78","--color-board-border-thick":"#f0eadd","--color-board-border-thin":"#2a4c78","--color-cell-bg":"#01344F","--color-cell-peer-bg":"#012a40","--color-cell-selected-bg":"#2a4c78","--color-cell-highlighted-bg":"rgba(243,217,153,0.2)","--color-cell-hover-bg":"rgba(243,217,153,0.1)","--color-note-highlighted-bg":"rgba(243,217,153,0.4)","--color-note-highlighted-text":"#1e3a5f","--color-hint-primary-bg":"rgba(243,217,153,0.5)","--color-hint-secondary-bg":"rgba(243,217,153,0.25)","--color-hint-text":"#f3d999","--color-hint-note-text":"#f0eadd","--color-hint-note-text-on-highlight":"#1e3a5f","--color-hint-icon":"#f3d999","--color-numpad-bg":"#012a40","--color-numpad-notes-bg":"#2a4c78","--color-numpad-text":"#f0eadd","--color-numpad-hover-bg":"rgba(74,106,130,0.8)","--color-controls-bg":"#012a40","--color-controls-bg-hover":"rgba(1,42,64,0.8)","--color-controls-text":"#f0eadd","--color-controls-hover-bg":"rgba(74,106,130,0.8)","--color-timer-bg":"#1e3a5f","--color-timer-text":"#a3b6c5","--color-victory-bg":"rgba(1,52,79,0.8)","--color-victory-title":"#f0eadd","--color-victory-stat-label":"#a3b6c5","--color-victory-stat-value":"#f3d999"} },
      };
      
      // --- components/icons.tsx ---
      
      function UndoIcon() { return (<svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2.5}><g transform="translate(2, 2)"><path strokeLinecap="round" strokeLinejoin="round" d="M15 15v-3.375A4.125 4.125 0 0010.875 7.5H4.5" /><path strokeLinecap="round" strokeLinejoin="round" d="M8.25 11.25L4.5 7.5l3.75-3.75" /></g></svg>); }
      function RedoIcon() { return (<svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2.5}><g transform="translate(2, 2)"><path strokeLinecap="round" strokeLinejoin="round" d="M5 15v-3.375A4.125 4.125 0 019.125 7.5H15.5" /><path strokeLinecap="round" strokeLinejoin="round" d="M11.75 11.25L15.5 7.5l-3.75-3.75" /></g></svg>); }
      function EraseIcon() { return (<svg xmlns="http://www.w3.org/2000/svg" className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>); }
      function NotesIcon() { return (<svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></svg>); }
      const bulbPath = "M12 2.25c-4.142 0-7.5 3.358-7.5 7.5 0 2.434 1.157 4.583 2.963 5.992v3.008a.75.75 0 00.75.75h7.584a.75.75 0 00.75-.75v-3.008c1.806-1.409 2.963-3.558 2.963-5.992 0-4.142-3.358-7.5-7.5-7.5zM9.75 21a.75.75 0 000 1.5h4.5a.75.75 0 000-1.5H9.75z";
      function HintIconFull() { return (<svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="currentColor" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={0.5}><path strokeLinecap="round" strokeLinejoin="round" d={bulbPath} /></svg>); }
      function HintIconEmpty() { return (<svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}><path strokeLinecap="round" strokeLinejoin="round" d={bulbPath} /></svg>); }
      function SettingsIcon() { return (<svg xmlns="http://www.w3.org/2000/svg" className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>); }
      function StatsIcon() { return (<svg xmlns="http://www.w3.org/2000/svg" className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2.5}><path strokeLinecap="round" strokeLinejoin="round" d="M7 16V8m4 8V4m4 12V6" /></svg>); }
      function ShareIcon() { return (<svg xmlns="http://www.w3.org/2000/svg" className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>); }
      const themePatterns = { default: [ "M 0,25 C 40,5 60,45 100,25 L 100,50 C 60,70 40,30 0,50 Z", "M 0,65 C 40,45 60,85 100,65 L 100,90 C 60,110 40,70 0,90 Z", "M 25,0 C 5,40 45,60 25,100 L 50,100 C 70,60 30,40 50,0 Z" ], minguo: [ "M 50,50 C 110,0 110,100 50,50 C -10,100 -10,0 50,50 Z", "M 50,50 C -10,50 50,-10 50,-10 C 50,-10 110,50 50,50 Z", "M 50,50 C -10,50 50,110 50,110 C 50,110 110,50 50,50 Z" ], forest: [ "M -10,80 C 40,110 80,-20 110,20 L 110,0 C 70,30 30,90 -10,60 Z", "M -10,90 C 20,40 60,120 110,70 L 110,50 C 70,110 30,30 -10,70 Z", "M -10,110 C 40,80 80,120 110,90 L 110,110 L -10,110 Z" ], luxury: [ "M 0,0 C 100,0 0,100 100,100 L 100,80 C 20,100 100,20 0,0 Z", "M 100,0 C 0,0 100,100 0,100 L 20,100 C 100,80 0,20 100,0 Z", "M 50,0 C 0,50 100,50 50,100 L 50,80 C 80,50 20,50 50,20 Z" ], retro: [ "M -10,50 C 20,20 80,20 110,50 L 110,80 C 80,-10 20,-10 -10,80 Z", "M -10,90 C 20,60 80,60 110,90 L 110,120 C 80,30 20,30 -10,120 Z", "M -10,10 C 20,-20 80,-20 110,10 L 110,40 C 80,-50 20,-50 -10,40 Z" ] };
      function ThemeIcon({ colors, patternId }) { const [p1, p2, p3] = themePatterns[patternId] || themePatterns.default; return (<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" preserveAspectRatio="none"><path d="M 0 0 H 100 V 100 H 0 Z" fill={colors[0]} /><path d={p1} fill={colors[1]} /><path d={p2} fill={colors[2]} /><path d={p3} fill={colors[3]} /></svg>); }
      
      // --- components/Cell.tsx ---
      
      function usePrevious(value) {
        const ref = useRef(undefined);
        useEffect(() => { ref.current = value; });
        return ref.current;
      }
      function Cell({ data, isSelected, isPeer, isHighlighted, isCorrect, onClick, isNotesMode, isAutoNotesEnabled, highlightedNumber, isHintPrimary, isHintSecondary, hintEffect, rowIndex, colIndex, className = '' }) {
        const { value, isInitial, isWrong, userNotes, autoNotes, eliminatedNotes } = data;
        const [isAnimating, setIsAnimating] = useState(false);
        const [isPopAnimating, setIsPopAnimating] = useState(false);
        const prevValue = usePrevious(value);
        useEffect(() => {
          if (isWrong && value !== 0 && value !== prevValue) setIsAnimating(true);
          if (isCorrect && !isInitial && value !== 0 && value !== prevValue) setIsPopAnimating(true);
        }, [value, isWrong, isCorrect, isInitial, prevValue]);
        const handleAnimationEnd = () => { setIsAnimating(false); setIsPopAnimating(false); };
        const getCellClasses = () => {
          let backgroundVar, textVar, fontClass = '', hoverClass;
          if (isInitial) { fontClass = 'font-semibold'; textVar = '--color-text-initial'; }
          else if (isWrong) textVar = '--color-text-wrong';
          else { if (isCorrect) fontClass = 'font-semibold'; textVar = '--color-text-user'; }
          if (isSelected) { backgroundVar = '--color-cell-selected-bg'; }
          else {
            hoverClass = 'hover:bg-[var(--color-cell-hover-bg)]';
            if (isHintPrimary) backgroundVar = '--color-hint-primary-bg';
            else if (isHintSecondary) backgroundVar = '--color-hint-secondary-bg';
            else if (isHighlighted && value !== 0) backgroundVar = '--color-cell-highlighted-bg';
            else if (isPeer) backgroundVar = '--color-cell-peer-bg';
            else backgroundVar = '--color-cell-bg';
          }
          const textClass = `text-[var(${textVar})]`;
          const backgroundClass = `bg-[var(${backgroundVar})]`;
          return ['aspect-square flex items-center justify-center text-2xl sm:text-3xl font-sans transition-all duration-200 cursor-pointer', backgroundClass, textClass, fontClass, hoverClass].filter(Boolean).join(' ');
        };
        const isHintGlowTarget = hintEffect?.type === 'cell-glow' && hintEffect.cell.row === rowIndex && hintEffect.cell.col === colIndex;
        const cellClasses = `${getCellClasses()} ${isAnimating ? 'animate-shake' : ''} ${isHintGlowTarget ? 'animate-hint-cell' : ''} ${className} ${isSelected ? 'z-10' : ''}`;
        const shouldShowNotesGrid = value === 0 && (userNotes.size > 0 || autoNotes.size > 0 || eliminatedNotes.size > 0);
        return (
          <div className={cellClasses} onClick={onClick} onAnimationEnd={handleAnimationEnd}>
            {value !== 0 ? (
              <span className={`${isPopAnimating ? 'animate-pop inline-block' : ''} transition-opacity duration-300 ${isNotesMode && !isInitial && !isCorrect ? 'opacity-70' : ''}`}>{value}</span>
            ) : shouldShowNotesGrid ? (
              <div className="grid grid-cols-3 grid-rows-3 w-full h-full p-px text-[10px] sm:text-xs leading-none">
                {Array.from({ length: 9 }).map((_, i) => {
                  const num = i + 1;
                  const isUserNote = userNotes.has(num), isAutoNote = autoNotes.has(num), isEliminationNote = eliminatedNotes.has(num);
                  if (!isUserNote && !isAutoNote && !isEliminationNote) return <div key={i} />;
                  const isNewlyEliminated = hintEffect?.type === 'note-pop' && hintEffect.eliminations.some(e => e.row === rowIndex && e.col === colIndex && e.num === num);
                  let noteClass = '', fontWeightClass = '';
                  const isHintedCell = isHintPrimary || isHintSecondary;
                  if (isEliminationNote) { noteClass = 'text-[var(--color-text-wrong)]'; fontWeightClass = 'font-semibold'; }
                  else {
                    if (isHintedCell) { noteClass = 'text-[var(--color-hint-note-text)]'; }
                    else if (isHighlighted && highlightedNumber === num) { noteClass = 'bg-[var(--color-note-highlighted-bg)] text-[var(--color-note-highlighted-text)] rounded-sm'; }
                    else { if (isAutoNotesEnabled) noteClass = isUserNote ? 'text-[var(--color-text-user-note)]' : 'text-[var(--color-text-note)]'; else noteClass = 'text-[var(--color-text-note)]'; }
                    if (isNotesMode || (isHighlighted && highlightedNumber === num)) { fontWeightClass = 'font-bold'; }
                    else if (isUserNote || !isAutoNotesEnabled) { fontWeightClass = 'font-medium'; }
                  }
                  return <div key={i} className={`flex items-center justify-center transition-all duration-200 ${noteClass} ${fontWeightClass} ${isNewlyEliminated ? 'animate-pop':''}`}>{num}</div>;
                })}
              </div>
            ) : null}
          </div>
        );
      }
      
      // --- components/SudokuBoard.tsx ---
      
      function SudokuBoard({ board, solution, selectedCell, onCellClick, isNotesMode, isDarkMode, forceDarkMode, isAutoNotesEnabled, isHighlightNotesEnabled, highlightedNumber, activeHint, hintEffect }) {
        const isDark = isDarkMode || forceDarkMode;
        return (
          <div className={`relative transition-all duration-300 ease-in-out aspect-square w-full transform-gpu ${isNotesMode ? 'scale-[1.03]' : ''}`}>
            <div className={`absolute inset-0 rounded-2xl bg-[var(--color-board-border-outer)]`}></div>
            <div className={`absolute inset-[6px] grid grid-cols-3 grid-rows-3 gap-[2px] bg-[var(--color-board-border-thick)] rounded-xl overflow-hidden`}>
              {Array.from({ length: 9 }).map((_, boxIndex) => (
                <div key={boxIndex} className={`grid grid-cols-3 grid-rows-3 gap-[1px] bg-[var(--color-board-border-thin)] ${boxIndex===0?'rounded-tl-xl':''} ${boxIndex===2?'rounded-tr-xl':''} ${boxIndex===6?'rounded-bl-xl':''} ${boxIndex===8?'rounded-br-xl':''}`}>
                  {Array.from({ length: 9 }).map((_, cellInBoxIndex) => {
                    const boxRowStart = Math.floor(boxIndex / 3) * 3, boxColStart = (boxIndex % 3) * 3;
                    const rowIndex = boxRowStart + Math.floor(cellInBoxIndex / 3), colIndex = boxColStart + (cellInBoxIndex % 3);
                    const cellData = board[rowIndex][colIndex];
                    const isSelected = selectedCell?.row === rowIndex && selectedCell?.col === colIndex;
                    const isPeer = selectedCell ? (selectedCell.row === rowIndex || selectedCell.col === colIndex || (Math.floor(selectedCell.row / 3) === Math.floor(rowIndex / 3) && Math.floor(selectedCell.col / 3) === Math.floor(colIndex / 3))) : false;
                    let isHighlighted = false;
                    if (highlightedNumber !== null && !isSelected) {
                      isHighlighted = cellData.value === highlightedNumber || (isHighlightNotesEnabled && cellData.value === 0 && (cellData.userNotes.has(highlightedNumber) || cellData.autoNotes.has(highlightedNumber)));
                    }
                    return (
                      <Fragment key={`${rowIndex}-${colIndex}`}>
                        <Cell data={cellData} isSelected={isSelected} isPeer={isPeer && !isSelected} isHighlighted={isHighlighted} isCorrect={!cellData.isInitial && cellData.value !== 0 && cellData.value === solution[rowIndex][colIndex]} onClick={() => onCellClick(rowIndex, colIndex)} isNotesMode={isNotesMode} isAutoNotesEnabled={isAutoNotesEnabled} highlightedNumber={highlightedNumber} isHintPrimary={!!activeHint?.primaryCells.some(c => c.row === rowIndex && c.col === colIndex)} isHintSecondary={!!activeHint?.secondaryCells.some(c => c.row === rowIndex && c.col === colIndex)} hintEffect={hintEffect} rowIndex={rowIndex} colIndex={colIndex} />
                      </Fragment>
                    );
                  })}
                </div>
              ))}
            </div>
          </div>
        );
      }
      
      // --- components/NumberPad.tsx ---
      
      function NumberPad({ onNumberClick, isNotesMode, highlightedNumber }) {
        const containerBgClass = isNotesMode ? 'bg-[var(--color-numpad-notes-bg)]' : 'bg-[var(--color-numpad-bg)]';
        return (
          <div className={`rounded-full p-1 flex justify-around items-center w-full transition-all duration-300 shadow-lg ${containerBgClass}`}>
            {Array.from({ length: 9 }).map((_, i) => {
              const num = i + 1;
              const isHighlighted = highlightedNumber === num;
              const baseButtonClass = 'w-12 h-12 sm:w-16 sm:h-16 flex items-center justify-center font-semibold text-3xl sm:text-4xl rounded-full focus:outline-none transition-all duration-200 transform active:scale-90';
              const highlightClass = isHighlighted ? 'text-[var(--color-accent)]' : 'text-[var(--color-numpad-text)]';
              const interactionClass = isHighlighted ? '' : 'hover:bg-[var(--color-numpad-hover-bg)] focus:bg-[var(--color-numpad-hover-bg)]';
              const buttonClasses = `${baseButtonClass} ${highlightClass} ${interactionClass}`;
              return (<button key={num} onClick={() => onNumberClick(num)} className={buttonClasses} aria-label={`Enter number ${num}`} aria-pressed={isHighlighted}>{num}</button>);
            })}
          </div>
        );
      }
      
      // --- components/Controls.tsx ---
      
      function Controls({ isNotesMode, onToggleNotesMode, onUndo, canUndo, onRedo, canRedo, onHint, isHintOnCooldown, cooldownDuration, onDelete, hintButtonEffect }) {
        const [popAnimation, setPopAnimation] = useState(false);
        const prevCooldown = useRef(isHintOnCooldown);
        const animationKey = useRef(0);
        useEffect(() => {
          if (prevCooldown.current && !isHintOnCooldown) setPopAnimation(true);
          prevCooldown.current = isHintOnCooldown;
        }, [isHintOnCooldown]);
        const handleHintClick = () => { if (!isHintOnCooldown) { animationKey.current += 1; onHint(); } };
        const baseClasses = "w-12 h-12 flex items-center justify-center rounded-full transition-all duration-300 transform focus:outline-none active:scale-90 disabled:opacity-30 disabled:cursor-not-allowed disabled:bg-transparent";
        const iconBtnClasses = 'text-[var(--color-controls-text)] hover:bg-[var(--color-controls-hover-bg)]';
        return (
          <div className="flex justify-center items-center text-[var(--color-controls-text)]">
            <button onClick={onUndo} disabled={!canUndo} className={`${baseClasses} ${iconBtnClasses} ${canRedo ? 'mr-1' : 'mr-2'}`} aria-label="Undo"><UndoIcon /></button>
            <div className={`transition-all duration-300 ease-in-out flex items-center justify-center ${canRedo ? 'w-12 opacity-100' : 'w-0 opacity-0'}`} style={{transitionProperty: 'width, opacity'}}>
              <button onClick={onRedo} disabled={!canRedo} className={`${baseClasses} ${iconBtnClasses}`} aria-label="Redo"><RedoIcon /></button>
            </div>
            <button onClick={onDelete} className={`${baseClasses} ${iconBtnClasses} ml-1`} aria-label="Delete"><EraseIcon /></button>
            <button onClick={onToggleNotesMode} className={`${baseClasses} ${isNotesMode ? 'bg-[var(--color-accent)] text-[var(--color-accent-text)] shadow-[0_0_15px_var(--color-accent-glow)]' : iconBtnClasses} ml-2`} aria-label="Notes Mode"><NotesIcon /></button>
            <button onClick={handleHintClick} disabled={isHintOnCooldown} className={`${baseClasses} text-[var(--color-hint-icon)] ${isHintOnCooldown ? '' : 'hover:bg-[var(--color-controls-hover-bg)]'} ${hintButtonEffect === 'shake' ? 'animate-shake' : ''} ${popAnimation ? 'animate-pop' : ''} ml-2`} onAnimationEnd={() => setPopAnimation(false)} aria-label="Hint">
              <div className="relative w-full h-full flex items-center justify-center">
                {isHintOnCooldown ? (<><HintIconEmpty /><div key={animationKey.current} className="absolute w-full h-full flex items-center justify-center animate-fill-up" style={{ animationDuration: `${cooldownDuration}s` }}><HintIconFull /></div></>) : <HintIconFull />}
              </div>
            </button>
          </div>
        );
      }
      
      // --- components/Header.tsx ---
      
      function Header({ onOpenSettings, onOpenStats, onTitleClick, isNewGameConfirmOpen }) {
        return (
          <header className="absolute left-0 right-0 w-full px-4 z-20" style={{ top: 'calc(env(safe-area-inset-top, 0px) + 0.5rem)' }}>
            <div className="relative w-full flex items-center justify-between h-12">
              <div className="flex-1 flex justify-start"><button onClick={onOpenSettings} className={`w-12 h-12 flex items-center justify-center rounded-full transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-accent)] text-[var(--color-text-secondary)] hover:bg-[var(--color-ui-bg-hover)]`} aria-label="Settings"><SettingsIcon /></button></div>
              <div className="flex-1 flex justify-center"><div className="relative"><h1 onClick={onTitleClick} className={`text-3xl font-bold tracking-tight cursor-pointer select-none transition-colors text-[var(--color-text-primary)] ${isNewGameConfirmOpen ? 'text-[var(--color-accent)]' : 'hover:text-[var(--color-accent)]'}`} aria-haspopup="true" aria-expanded={isNewGameConfirmOpen}>Sudoku</h1></div></div>
              <div className="flex-1 flex justify-end"><button onClick={onOpenStats} className={`w-12 h-12 flex items-center justify-center rounded-full transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-accent)] text-[var(--color-text-secondary)] hover:bg-[var(--color-ui-bg-hover)]`} aria-label="Stats"><StatsIcon /></button></div>
            </div>
          </header>
        );
      }
      
      // --- components/VictoryScreen.tsx ---
      
      function StatItem({ label, value }) { return (<div className="flex flex-col items-center"><span className="text-sm font-medium text-[var(--color-victory-stat-label)] uppercase tracking-wider">{label}</span><span className="text-3xl font-bold text-[var(--color-victory-stat-value)]">{value}</span></div>); }
      const formatTimeForVictory = (ms) => ms === null || ms <= 0 ? '-:--' : `${Math.floor(ms/60000)}:${(Math.floor(ms/1000)%60).toString().padStart(2,'0')}`;
      function VictoryScreen({ message, moves, elapsedTime, mistakes, hints, sharerStats }) {
        const [showContainer, setShowContainer] = useState(false);
        const [showTitle, setShowTitle] = useState(false);
        const [showStats, setShowStats] = useState(false);
        const [showSharerStats, setShowSharerStats] = useState(false);
        useEffect(() => {
          const t1 = setTimeout(() => setShowContainer(true), 100);
          const t2 = setTimeout(() => setShowTitle(true), 300);
          const t3 = setTimeout(() => setShowStats(true), 500);
          const t4 = setTimeout(() => setShowSharerStats(true), 700);
          return () => { clearTimeout(t1); clearTimeout(t2); clearTimeout(t3); clearTimeout(t4); };
        }, []);
        const titleSize = message.length > 35 ? 'text-xl sm:text-2xl' : (message.length > 20 ? 'text-2xl sm:text-3xl' : 'text-3xl');
        return (
          <div className="absolute inset-0 z-[100] flex items-center justify-center pointer-events-none">
            <div className={`w-auto min-w-[320px] max-w-sm flex flex-col items-center gap-4 bg-[var(--color-victory-bg)] backdrop-blur p-8 rounded-2xl shadow-2xl transition-all duration-500 ease-in-out ${showContainer ? 'opacity-100 translate-y-0 scale-100' : 'opacity-0 -translate-y-4 scale-95'}`}>
              <h2 className={`text-center font-bold text-[var(--color-victory-title)] transition-all duration-500 ease-in-out ${titleSize} ${showTitle ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-4'}`}>{message}</h2>
              <div className="flex flex-col items-center gap-2 w-full">
                <h3 className="text-base font-semibold text-[var(--color-victory-stat-label)] uppercase tracking-wider">Your Results</h3>
                <div className={`flex justify-center gap-x-6 sm:gap-x-8 transition-all duration-500 ease-in-out ${showStats ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
                  <StatItem label="Time" value={formatTimeForVictory(elapsedTime)} /><StatItem label="Moves" value={moves} /><StatItem label="Mistakes" value={mistakes} /><StatItem label="Hints" value={hints} />
                </div>
              </div>
              {sharerStats && (
                <div className={`flex flex-col items-center gap-2 mt-2 pt-2 border-t border-[var(--color-victory-stat-label)] border-opacity-30 w-full transition-all duration-500 ease-in-out ${showSharerStats ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`} style={{transitionDelay: '200ms'}}>
                    <h3 className="text-base font-semibold text-[var(--color-victory-stat-label)] uppercase tracking-wider">Challenger's Results</h3>
                    <div className="flex justify-center gap-x-6 sm:gap-x-8">
                      <StatItem label="Time" value={formatTimeForVictory(sharerStats.time)} /><StatItem label="Moves" value={sharerStats.moves} /><StatItem label="Mistakes" value={sharerStats.mistakes} /><StatItem label="Hints" value={sharerStats.hints} />
                    </div>
                </div>
              )}
            </div>
          </div>
        );
      }
      
      // --- components/StatsPanel.tsx ---
      
      function StatsPanel({ isOpen, onClose, stats }) {
        const playedDifficulties = [{id:'easy',l:'Easy'},{id:'medium',l:'Medium'},{id:'hard',l:'Hard'},{id:'professional',l:'Pro'}].filter(d => stats.byDifficulty[d.id].wins > 0);
        const [activeTab, setActiveTab] = useState(null);
        useEffect(() => { 
          if (playedDifficulties.length > 0 && (!activeTab || !playedDifficulties.some(d => d.id === activeTab))) { setActiveTab(playedDifficulties[0].id); }
          else if (playedDifficulties.length === 0) { setActiveTab(null); }
        }, [stats, activeTab, playedDifficulties]);
        if (!isOpen) return null;
        const formatTime = (ms) => ms === null || ms <= 0 ? '-:--' : `${Math.floor(ms/60000)}:${(Math.floor(ms/1000)%60).toString().padStart(2,'0')}`;
        const winPercent = stats.gamesPlayed > 0 ? Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0;
        const currentStats = activeTab ? stats.byDifficulty[activeTab] : null;
        return (
          <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/30" aria-modal="true" role="dialog" onClick={onClose}>
            <div onClick={(e) => e.stopPropagation()} className={`w-full max-w-md m-4 p-6 rounded-2xl shadow-2xl border flex flex-col gap-6 transform transition-all duration-300 ease-in-out ${isOpen ? 'opacity-100 scale-100' : 'opacity-0 scale-95'} bg-[var(--color-ui-bg-translucent)] border-[var(--color-ui-border)] backdrop-blur-sm text-[var(--color-text-primary)]`}>
              <h2 className="text-2xl font-bold text-center">Statistics</h2>
              <div className="grid grid-cols-3 gap-3">
                  <StatItem label="Played" value={stats.gamesPlayed} />
                  <StatItem label="Wins" value={stats.gamesWon} />
                  <StatItem label="High Score" value={(stats.highScore || 0).toLocaleString()} />
                  <StatItem label="Win %" value={`${winPercent}%`} />
                  <StatItem label="Avg. Moves" value={stats.gamesWon > 0 ? (stats.totalMoves / stats.gamesWon).toFixed(1) : '0'} />
                  <StatItem label="Avg. Mistakes" value={stats.gamesWon > 0 ? (stats.totalMistakes / stats.gamesWon).toFixed(1) : '0'} />
              </div>
              {playedDifficulties.length > 0 && currentStats && (
                <div className="flex flex-col gap-3">
                  <h3 className="text-lg font-semibold text-center mt-2">By Difficulty</h3>
                  <div className="flex justify-center gap-2">
                      {playedDifficulties.map(({ id, l }) => <button key={id} onClick={() => setActiveTab(id)} className={`text-center font-semibold py-2 px-4 rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-[var(--color-accent)] focus:ring-offset-2 ring-offset-[var(--color-ui-bg)] text-sm ${activeTab === id ? 'bg-[var(--color-accent)] text-[var(--color-accent-text)] shadow-md' : 'bg-[var(--color-btn-secondary-bg)] hover:bg-[var(--color-btn-secondary-bg-hover)]'}`} aria-pressed={activeTab === id}>{l}</button> )}
                  </div>
                  <div className="grid grid-cols-3 gap-3">
                      <StatItem label="Wins" value={currentStats.wins} />
                      <StatItem label="Best Time" value={formatTime(currentStats.bestTime)} />
                      <StatItem label="Avg. Time" value={formatTime(currentStats.wins > 0 ? currentStats.totalTime / currentStats.wins : 0)} />
                  </div>
                </div>
              )}
              <div className="flex justify-center mt-2"><button onClick={onClose} className={`font-bold py-2 px-6 rounded-lg shadow-md transition-colors bg-[var(--color-accent)] hover:bg-[var(--color-accent-hover)] text-[var(--color-accent-text)]`}>Done</button></div>
            </div>
          </div>
        );
      }
      
      // --- components/SettingsPanel.tsx ---
      
      function Toggle({ id, checked, onChange, label, description }) {
        return (
          <div className="flex justify-between items-center">
            <label htmlFor={id} className="font-medium pr-4">{label}<p className={`text-xs font-normal text-[var(--color-text-secondary)]`}>{description}</p></label>
            <button id={id} onClick={onChange} role="switch" aria-checked={checked} className={`relative inline-flex h-6 w-11 shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-[var(--color-accent)] focus:ring-offset-2 focus:ring-offset-[var(--color-ui-bg)] ${checked ? 'bg-[var(--color-accent)]' : 'bg-[var(--color-toggle-bg)]'}`}><span aria-hidden="true" className={`pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out ${checked ? 'translate-x-5' : 'translate-x-0'}`} /></button>
          </div>
        );
      }
      function SettingsPanel({ isOpen, onClose, currentDifficulty, theme, setTheme, colorMode, setColorMode, onFillBoard, isAutoNotesEnabled, onSetAutoNotes, isHighlightNotesEnabled, onSetHighlightNotes, isTimerVisible, onSetIsTimerVisible }) {
        const [selectedDifficulty, setSelectedDifficulty] = useState(currentDifficulty);
        const [isThemeSelectorOpen, setIsThemeSelectorOpen] = useState(false);
        const themePickerRef = useRef(null);
        useEffect(() => { if (isOpen) setSelectedDifficulty(currentDifficulty); }, [isOpen, currentDifficulty]);
        useEffect(() => {
          const handleClickOutside = (event) => { if (themePickerRef.current && !themePickerRef.current.contains(event.target)) { setIsThemeSelectorOpen(false); } };
          if (isThemeSelectorOpen) document.addEventListener("mousedown", handleClickOutside);
          return () => document.removeEventListener("mousedown", handleClickOutside);
        }, [isThemeSelectorOpen]);
        if (!isOpen) return null;
        const baseBtn = 'w-full text-center font-semibold py-3 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-[var(--color-accent)] focus:ring-offset-2 ring-offset-[var(--color-ui-bg)]';
        const selectedBtn = 'bg-[var(--color-accent)] text-[var(--color-accent-text)] shadow-md';
        const unselectedBtn = 'bg-[var(--color-btn-secondary-bg)] hover:bg-[var(--color-btn-secondary-bg-hover)]';
        const baseModeBtn = 'w-full text-center font-semibold py-2 px-4 rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-[var(--color-accent)] focus:ring-offset-2 ring-offset-[var(--color-ui-bg)]';
        return (
          <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/30" aria-modal="true" role="dialog">
            <div className={`w-full max-w-md m-4 p-6 rounded-2xl shadow-2xl border flex flex-col gap-6 transform transition-all duration-300 ease-in-out ${isOpen ? 'opacity-100 scale-100' : 'opacity-0 scale-95'} bg-[var(--color-ui-bg-translucent)] border-[var(--color-ui-border)] backdrop-blur-sm text-[var(--color-text-primary)]`}>
              <h2 className="text-2xl font-bold text-center">Settings</h2>
              <div>
                <h3 className="text-lg font-semibold mb-2">Difficulty</h3>
                <div className="grid grid-cols-2 gap-3">
                  {[{id:'easy',l:'Easy'},{id:'medium',l:'Medium'},{id:'hard',l:'Hard'},{id:'professional',l:'Pro'}].map(({ id, l }) => <button key={id} onClick={() => setSelectedDifficulty(id)} className={`${baseBtn} ${selectedDifficulty === id ? selectedBtn : unselectedBtn}`} aria-pressed={selectedDifficulty === id}>{l}</button>)}
                </div>
              </div>
              <div>
                <h3 className="text-lg font-semibold mb-2">Theme</h3>
                <div className="relative" ref={themePickerRef}>
                  <button onClick={() => setIsThemeSelectorOpen(!isThemeSelectorOpen)} className="w-full flex items-center justify-between p-3 rounded-lg bg-[var(--color-ui-bg-secondary)] hover:bg-[var(--color-ui-bg-hover)] text-[var(--color-text-primary)] focus:outline-none focus:ring-2 focus:ring-[var(--color-accent)] focus:ring-offset-2 ring-offset-[var(--color-ui-bg)] transition-colors" aria-haspopup="true" aria-expanded={isThemeSelectorOpen}>
                    <span>{themes[theme].name}</span>
                    <div className="w-6 h-6 rounded-full border border-black/10 overflow-hidden"><ThemeIcon colors={themes[theme].gradientColors} patternId={theme} /></div>
                  </button>
                  <div className={`absolute top-full left-0 right-0 mt-2 p-4 rounded-lg bg-[var(--color-ui-bg)] shadow-lg z-10 border border-[var(--color-ui-border)] transition-all duration-200 ease-out origin-top ${isThemeSelectorOpen ? 'opacity-100 scale-100' : 'opacity-0 scale-95 pointer-events-none'}`}>
                    <div className="grid grid-cols-3 gap-4">
                      {Object.entries(themes).map(([id, { name, gradientColors }]) => (
                        <div key={id} className="flex flex-col items-center gap-2">
                          <button onClick={() => { setTheme(id); setIsThemeSelectorOpen(false); }} className={`w-full aspect-square rounded-lg overflow-hidden transition-all duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 ring-offset-[var(--color-ui-bg)] ${theme === id ? 'ring-2 ring-[var(--color-accent)]' : 'ring-1 ring-transparent'}`} aria-pressed={theme === id}><ThemeIcon colors={gradientColors} patternId={id} /></button>
                          <span className={`text-xs font-medium transition-colors ${theme === id ? 'text-[var(--color-text-primary)]' : 'text-[var(--color-text-secondary)]'}`}>{name}</span>
                        </div>
                      ))}
                    </div>
                    <div className="mt-4 pt-4 border-t border-[var(--color-ui-border)]">
                        <h4 className="text-base font-semibold mb-2 text-center">Color Mode</h4>
                        <div className="grid grid-cols-3 gap-2 p-1 rounded-lg bg-[var(--color-ui-bg-secondary)]">
                            {['light', 'dark', 'system'].map(mode => (<button key={mode} onClick={() => setColorMode(mode)} className={`${baseModeBtn} ${colorMode === mode ? selectedBtn : 'hover:bg-[var(--color-btn-secondary-bg-hover)]'}`}>{mode.charAt(0).toUpperCase() + mode.slice(1)}</button>))}
                        </div>
                    </div>
                  </div>
                </div>
              </div>
              <div className="flex flex-col gap-4">
                <h3 className="text-lg font-semibold">Gameplay</h3>
                <Toggle id="auto-notes" checked={isAutoNotesEnabled} onChange={() => onSetAutoNotes(!isAutoNotesEnabled)} label="Auto-Pencil" description="Automatically fill in all possible notes for empty cells." />
                <Toggle id="highlight-notes" checked={isHighlightNotesEnabled} onChange={() => onSetHighlightNotes(!isHighlightNotesEnabled)} label="Highlight Notes" description="Highlight cells that have a note matching the selected number." />
                <Toggle id="timer-visible" checked={isTimerVisible} onChange={() => onSetIsTimerVisible(!isTimerVisible)} label="Show Timer" description="Display the timer while playing the game." />
              </div>
              <div className="flex justify-center gap-4 mt-2"><button onClick={() => onClose(selectedDifficulty)} className={`font-bold py-2 px-6 rounded-lg shadow-md transition-colors bg-[var(--color-accent)] hover:bg-[var(--color-accent-hover)] text-[var(--color-accent-text)]`}>Done</button></div>
              <button onClick={onFillBoard} className="absolute bottom-2 right-2 text-xs text-transparent hover:text-[var(--color-text-secondary)]">Solve</button>
            </div>
          </div>
        );
      }
      
      // --- components/HintTutorial.tsx ---
      
      function TutorialGrid({ data }) {
        const highlightClasses = { primary: 'bg-[var(--color-hint-primary-bg)]', secondary: 'bg-[var(--color-hint-secondary-bg)]' };
        const rowClassMap = { 1: 'grid-rows-1', 2: 'grid-rows-2', 3: 'grid-rows-3', 4: 'grid-rows-4', 5: 'grid-rows-5', };
        const rowClass = rowClassMap[data.length] || 'grid-rows-1';
        return (
          <div className={`grid gap-[1px] bg-[var(--color-board-border-thin)] rounded-lg overflow-hidden ${rowClass}`} style={{ gridTemplateColumns: `repeat(${data[0].length}, minmax(0, 1fr))` }}>
            {data.flat().map((cell, index) => {
              const numCols = data[0].length;
              const rowIndex = Math.floor(index / numCols);
              const colIndex = index % numCols;
              const isCellHighlighted = !!cell.highlights?.cell;
              const cellHighlightClass = isCellHighlighted ? highlightClasses[cell.highlights.cell] : '';
              const borderClasses = [];
              if ((colIndex + 1) % 3 === 0 && colIndex < numCols - 1) { borderClasses.push('border-r-[2px]'); }
              if ((rowIndex + 1) % 3 === 0 && rowIndex < data.length - 1) { borderClasses.push('border-b-[2px]'); }
              if (borderClasses.length > 0) { borderClasses.push('border-[var(--color-board-border-thick)]'); }
              return (
                <div key={index} className={`aspect-square flex items-center justify-center font-sans bg-[var(--color-cell-bg)] ${cellHighlightClass} ${borderClasses.join(' ')}`}>
                  {cell.value ? (<span className="font-bold text-[var(--color-text-primary)] text-2xl sm:text-3xl">{cell.value}</span>) :
                   cell.notes ? (
                    <div className="grid grid-cols-3 grid-rows-3 w-full h-full p-px text-xs sm:text-sm leading-none">
                      {Array.from({ length: 9 }).map((_, i) => {
                        const num = i + 1;
                        if (!cell.notes?.includes(num)) return <div key={i} />;
                        let noteClass = '';
                        if (isCellHighlighted) {
                            noteClass = 'text-[var(--color-hint-note-text)] font-medium';
                        } else {
                            noteClass = 'text-[var(--color-text-note)] font-medium';
                        }
                        const numHighlightType = cell.highlights?.notes?.[num];
                        if (numHighlightType === 'elim') {
                            noteClass = 'text-[var(--color-text-wrong)] line-through font-bold';
                        } else if (numHighlightType) {
                            if (isCellHighlighted) {
                                noteClass = 'font-bold text-[var(--color-hint-note-text-on-highlight)]';
                            } else {
                                noteClass = numHighlightType === 'primary' ? 'font-extrabold text-[var(--color-accent)]' : 'font-bold text-[var(--color-text-user)]';
                            }
                        }
                        return <div key={i} className={`flex items-center justify-center ${noteClass}`}>{num}</div>;
                      })}
                    </div>
                  ) : null}
                </div>
              );
            })}
          </div>
        );
      }
      function HintTutorial({ hintType, onClose }) {
        const tutorial = getTutorialForHint(hintType || '');
        const [showContent, setShowContent] = useState(false);
        useEffect(() => {
          if (hintType) { const timer = setTimeout(() => setShowContent(true), 50); return () => clearTimeout(timer); }
          else { setShowContent(false); }
        }, [hintType]);
        if (!hintType || !tutorial) return null;
        const numCols = tutorial.graphic[0].length;
        let modalWidthClass = 'max-w-sm';
        let gridWrapperClass = 'w-full';
        if (numCols <= 4) { gridWrapperClass = 'w-72'; }
        else if (numCols > 5) { modalWidthClass = 'max-w-2xl'; }
        return (
          <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/50 transition-opacity duration-300" onClick={onClose} aria-modal="true" role="dialog">
            <div onClick={(e) => e.stopPropagation()} className={`w-full ${modalWidthClass} m-4 p-6 rounded-2xl shadow-2xl border flex flex-col gap-4 bg-[var(--color-ui-bg-translucent)] border-[var(--color-ui-border)] backdrop-blur-sm text-[var(--color-text-primary)] transition-all duration-300 ease-in-out ${showContent ? 'opacity-100 scale-100' : 'opacity-0 scale-95'}`}>
              {tutorial ? (
                  <>
                      <h2 className="text-xl font-bold text-center">{tutorial.title}</h2>
                      <p className="text-sm text-center text-[var(--color-text-secondary)]">{tutorial.description}</p>
                      <div className={`mx-auto p-1 bg-[var(--color-board-border-thick)] rounded-xl ${gridWrapperClass}`}><TutorialGrid data={tutorial.graphic} /></div>
                  </>
              ) : (<p className="text-sm text-center text-[var(--color-text-secondary)]">No tutorial available for this hint.</p>)}
              <div className="flex justify-center mt-2"><button onClick={onClose} className={`font-bold py-2 px-6 rounded-lg shadow-md transition-colors bg-[var(--color-accent)] hover:bg-[var(--color-accent-hover)] text-[var(--color-accent-text)]`}>Got it</button></div>
            </div>
          </div>
        );
      }

      // --- App.tsx ---
      
      const calculateScore = (difficulty, elapsedTime, movesCount, mistakesCount, hintUsageCount, isAutoNotesEnabled) => {
          const basePoints = 1500;
          const timePenalty = Math.floor(elapsedTime / 1000 / 3);
          const movesPenalty = movesCount * 5;
          const mistakesPenalty = mistakesCount * 50;
          const hintsPenalty = hintUsageCount * 100;
          const difficultyMultiplier = { easy: 0.8, medium: 1.0, hard: 1.2, professional: 1.5, };
          const autoNotesMultiplier = isAutoNotesEnabled ? 1.0 : 1.25;
          let score = Math.max(0, basePoints - timePenalty - movesPenalty - mistakesPenalty - hintsPenalty);
          score *= (difficultyMultiplier[difficulty] || 1.0);
          score *= autoNotesMultiplier;
          return Math.round(score);
      };
      
      function App() {
        const [board, setBoard] = useState([]);
        const [solution, setSolution] = useState([]);
        const [selectedCell, setSelectedCell] = useState(null);
        const [isNotesMode, setIsNotesMode] = useState(false);
        const [history, setHistory] = useState([]);
        const [redoHistory, setRedoHistory] = useState([]);
        const [isGameWon, setIsGameWon] = useState(false);
        const [animationState, setAnimationState] = useState('idle');
        const [victoryMessage, setVictoryMessage] = useState('');
        const [isSettingsOpen, setIsSettingsOpen] = useState(false);
        const [isStatsOpen, setIsStatsOpen] = useState(false);
        const [difficulty, setDifficulty] = useState(() => localStorage.getItem('sudoku-difficulty') || 'medium');
        const [isAutoNotesEnabled, setIsAutoNotesEnabled] = useState(() => localStorage.getItem('sudoku-auto-notes') === 'true');
        const [isHighlightNotesEnabled, setIsHighlightNotesEnabled] = useState(() => localStorage.getItem('sudoku-highlight-notes') === 'true');
        const [theme, setTheme] = useState(() => localStorage.getItem('sudoku-theme') || 'default');
        const [colorMode, setColorMode] = useState(() => localStorage.getItem('sudoku-color-mode') || 'system');
        const [isDarkMode, setIsDarkMode] = useState(false);
        const [stats, setStats] = useState(() => { try { const saved = JSON.parse(localStorage.getItem('sudoku-stats')); const defaultStats = {gamesPlayed:0,gamesWon:0,totalMoves:0,totalMistakes:0,highScore:0,byDifficulty:{easy:{wins:0,bestTime:null,totalTime:0},medium:{wins:0,bestTime:null,totalTime:0},hard:{wins:0,bestTime:null,totalTime:0},professional:{wins:0,bestTime:null,totalTime:0}}}; return { ...defaultStats, ...saved }; } catch (e) { return {gamesPlayed:0,gamesWon:0,totalMoves:0,totalMistakes:0,highScore:0,byDifficulty:{easy:{wins:0,bestTime:null,totalTime:0},medium:{wins:0,bestTime:null,totalTime:0},hard:{wins:0,bestTime:null,totalTime:0},professional:{wins:0,bestTime:null,totalTime:0}}}; }});
        const [activeHint, setActiveHint] = useState(null);
        const [isHintOnCooldown, setIsHintOnCooldown] = useState(false);
        const [hintUsageCount, setHintUsageCount] = useState(0);
        const [hintEffect, setHintEffect] = useState(null);
        const [hintButtonEffect, setHintButtonEffect] = useState(null);
        const cooldownIntervalRef = useRef(null);
        const [elapsedTime, setElapsedTime] = useState(0);
        const [isTimerRunning, setIsTimerRunning] = useState(false);
        const [movesCount, setMovesCount] = useState(0);
        const [mistakesCount, setMistakesCount] = useState(0);
        const [isTimerVisible, setIsTimerVisible] = useState(() => localStorage.getItem('sudoku-timer-visible') === 'true');
        const [highlightedNumPad, setHighlightedNumPad] = useState(null);
        const [showNewGameConfirm, setShowNewGameConfirm] = useState(false);
        const [initialPuzzle, setInitialPuzzle] = useState('');
        const [shareFeedback, setShareFeedback] = useState('');
        const [sharerStats, setSharerStats] = useState(null);
        const [tutorialHintType, setTutorialHintType] = useState(null);
        const isUIBlocked = isSettingsOpen || isStatsOpen || !!tutorialHintType;
        const startCooldown = useCallback(() => {
          if (cooldownIntervalRef.current) clearInterval(cooldownIntervalRef.current);
          setIsHintOnCooldown(true);
          cooldownIntervalRef.current = setTimeout(() => setIsHintOnCooldown(false), 4000);
        }, []);
        const formatTime = (ms) => `${Math.floor(ms/60000)}:${(Math.floor(ms/1000)%60).toString().padStart(2,'0')}`;
        const triggerWinState = useCallback(() => {
          setIsTimerRunning(false);
          const msgs = ["Perfectly solved.", "This solve was... inevitable.", "Numbers... Assemble.", "That's my secret: I'm always thinking.", "The Logic is strong with this one.", "This is the way.", "We will watch your career with great interest.", "True Jedi.", "Never tell me the odds!", "My precious... solution.", "One does not simply solve this grid... but you did.", "Mischief Managed.", "You're a wizard, solver.", "10 points for that solve!", "Houston, we have a solution.", "Are you not entertained?!", "This puzzle has been terminated.", "What a solve!", "This is Sudoku!"];
          const gameDuration = elapsedTime;
          const gameScore = calculateScore(difficulty, elapsedTime, movesCount, mistakesCount, hintUsageCount, isAutoNotesEnabled);
          setStats(prev => { const diffStats = prev.byDifficulty[difficulty]; const best = diffStats.bestTime === null || gameDuration < diffStats.bestTime ? gameDuration : diffStats.bestTime; const newHighScore = Math.max(prev.highScore || 0, gameScore); return {...prev, gamesWon: prev.gamesWon+1, totalMoves: prev.totalMoves+movesCount, totalMistakes: prev.totalMistakes+mistakesCount, highScore: newHighScore, byDifficulty: {...prev.byDifficulty, [difficulty]: { wins: diffStats.wins+1, bestTime: best, totalTime: diffStats.totalTime+gameDuration }}}; });
          setVictoryMessage(msgs[Math.floor(Math.random() * msgs.length)]);
          setIsGameWon(true);
          setSelectedCell(null);
          setActiveHint(null);
          localStorage.removeItem('sudoku-saved-game');
        }, [elapsedTime, difficulty, movesCount, mistakesCount, hintUsageCount, isAutoNotesEnabled]);
        const checkWinCondition = useCallback((board) => {
          if (solution.length === 0) return false;
          for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) if (board[r][c].value === 0 || board[r][c].value !== solution[r][c]) return false;
          return true;
        }, [solution]);
        const startNewGame = useCallback((gameDifficulty) => {
          setBoard([]);
          setTimeout(() => {
              const { puzzle: newPuzzle, solution: newSolution } = generateSudoku(gameDifficulty);
              const puzzleString = newPuzzle.map(row => row.join('')).join('');
              setInitialPuzzle(puzzleString);
              setStats(prev => ({ ...prev, gamesPlayed: prev.gamesPlayed + 1 }));
              setSolution(newSolution);
              let newBoard = newPuzzle.map(row => row.map(value => ({ value, isInitial: value !== 0, isWrong: false, userNotes: new Set(), autoNotes: new Set(), eliminatedNotes: new Set() })));
              if (isAutoNotesEnabled) { for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) if (newBoard[r][c].value === 0) newBoard[r][c].autoNotes = calculateCandidates(newBoard, r, c); }
              setBoard(newBoard);
              setSelectedCell(null); setHighlightedNumPad(null); setIsNotesMode(false); setHistory([]); setRedoHistory([]); setIsGameWon(false); setAnimationState('idle'); setActiveHint(null); setHintEffect(null); setHintButtonEffect(null); setIsHintOnCooldown(false); if (cooldownIntervalRef.current) clearTimeout(cooldownIntervalRef.current); setHintUsageCount(0); setElapsedTime(0); setIsTimerRunning(true); setMovesCount(0); setMistakesCount(0); setSharerStats(null);
          }, 10);
        }, [isAutoNotesEnabled]);
        const startSharedGame = useCallback((puzzleString) => {
          if (!puzzleString || puzzleString.length !== 81 || !/^\d+$/.test(puzzleString)) { startNewGame(difficulty); return; }
          setBoard([]);
          setTimeout(() => {
              const newPuzzle = [];
              for (let i = 0; i < 9; i++) { newPuzzle.push(puzzleString.substring(i * 9, i * 9 + 9).split('').map(Number)); }
              const newSolutionGrid = newPuzzle.map(row => [...row]);
              if (!solveGrid(newSolutionGrid)) { console.error("Shared puzzle is unsolvable."); startNewGame(difficulty); return; }
              setInitialPuzzle(puzzleString);
              setStats(prev => ({ ...prev, gamesPlayed: prev.gamesPlayed + 1 }));
              setSolution(newSolutionGrid);
              let newBoard = newPuzzle.map(row => row.map(value => ({ value, isInitial: value !== 0, isWrong: false, userNotes: new Set(), autoNotes: new Set(), eliminatedNotes: new Set() })));
              if (isAutoNotesEnabled) { for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) if (newBoard[r][c].value === 0) newBoard[r][c].autoNotes = calculateCandidates(newBoard, r, c); }
              setBoard(newBoard);
              setSelectedCell(null); setHighlightedNumPad(null); setIsNotesMode(false); setHistory([]); setRedoHistory([]); setIsGameWon(false); setAnimationState('idle'); setActiveHint(null); setHintEffect(null); setHintButtonEffect(null); setIsHintOnCooldown(false); if (cooldownIntervalRef.current) clearTimeout(cooldownIntervalRef.current); setHintUsageCount(0); setElapsedTime(0); setIsTimerRunning(true); setMovesCount(0); setMistakesCount(0);
          }, 10);
        }, [isAutoNotesEnabled, difficulty, startNewGame]);
        const deepCopyBoard = (board) => board.map(r => r.map(c => ({...c, userNotes: new Set(c.userNotes), autoNotes: new Set(c.autoNotes), eliminatedNotes: new Set(c.eliminatedNotes)})));
        const placeNumberOnBoard = useCallback((row, col, num, isFromHint = false) => {
          setHistory(prev => [...prev, board]);
          setRedoHistory([]);
          setActiveHint(null);
          const newBoard = deepCopyBoard(board);
          const cell = newBoard[row][col];
          if (!isFromHint) setMovesCount(prev => prev + 1);
          cell.value = num;
          cell.userNotes.clear(); cell.autoNotes.clear(); cell.eliminatedNotes.clear();
          const isCorrect = solution[row][col] === num;
          cell.isWrong = !isCorrect;
          if (!isCorrect && !isFromHint) setMistakesCount(prev => prev + 1);
          if (isCorrect) {
              if (!isFromHint) setSelectedCell(null);
              for (let c = 0; c < 9; c++) { newBoard[row][c].userNotes.delete(num); newBoard[row][c].autoNotes.delete(num); }
              for (let r = 0; r < 9; r++) { newBoard[r][col].userNotes.delete(num); newBoard[r][col].autoNotes.delete(num); }
              const boxR = Math.floor(row / 3) * 3, boxC = Math.floor(col / 3) * 3;
              for (let r = boxR; r < boxR + 3; r++) for (let c = boxC; c < boxC + 3; c++) { newBoard[r][c].userNotes.delete(num); newBoard[r][c].autoNotes.delete(num); }
              if (checkWinCondition(newBoard)) triggerWinState();
          }
          setBoard(newBoard);
        }, [board, solution, checkWinCondition, triggerWinState]);
        const handleNumberClick = useCallback((num) => {
          if (!selectedCell || isGameWon || solution.length === 0 || board[selectedCell.row][selectedCell.col].isInitial) return;
          const { row, col } = selectedCell;
          if (isNotesMode) {
              setHistory(prev => [...prev, board]);
              setRedoHistory([]);
              setActiveHint(null);
              const newBoard = deepCopyBoard(board);
              const cell = newBoard[row][col];
              if (cell.userNotes.has(num) || cell.autoNotes.has(num)) { cell.userNotes.delete(num); cell.autoNotes.delete(num); }
              else cell.userNotes.add(num);
              cell.value = 0;
              setBoard(newBoard);
          } else {
              placeNumberOnBoard(row, col, num);
          }
        }, [board, isNotesMode, selectedCell, isGameWon, solution, placeNumberOnBoard]);
        const handleNumPadAction = (num) => {
          if (selectedCell) { handleNumberClick(num); }
          else if (isNotesMode) { setHighlightedNumPad(prev => prev === num ? null : num); }
        };
        const handleDelete = useCallback(() => {
          if (!selectedCell || isGameWon) return;
          const { row, col } = selectedCell;
          const cell = board[row][col];
          if (cell.isInitial || (cell.value === 0 && cell.userNotes.size === 0 && cell.autoNotes.size === 0 && cell.eliminatedNotes.size === 0)) return;
          setHistory(prev => [...prev, board]);
          setRedoHistory([]);
          setActiveHint(null);
          const newBoard = deepCopyBoard(board);
          Object.assign(newBoard[row][col], { value: 0, userNotes: new Set(), autoNotes: new Set(), eliminatedNotes: new Set(), isWrong: false });
          setBoard(newBoard);
        }, [board, selectedCell, isGameWon]);
        const handleHint = useCallback(() => {
          if (isHintOnCooldown || isGameWon || solution.length === 0) return;
          if (activeHint) {
              if (activeHint.solve) placeNumberOnBoard(activeHint.solve.row, activeHint.solve.col, activeHint.solve.num, true);
              else if (activeHint.eliminations?.length > 0) {
                  setHistory(prev => [...prev, board]);
                  setRedoHistory([]);
                  const newBoard = deepCopyBoard(board);
                  activeHint.eliminations.forEach(({ row, col, num }) => {
                      newBoard[row][col].eliminatedNotes.add(num);
                      newBoard[row][col].userNotes.delete(num);
                      newBoard[row][col].autoNotes.delete(num);
                  });
                  setBoard(newBoard);
                  setHintEffect({ type: 'note-pop', eliminations: activeHint.eliminations });
              }
              setActiveHint(null);
              return;
          }
          setSelectedCell(null);
          const hint = findHint(board, difficulty, null);
          if (hint) {
              setActiveHint(hint);
              if (hint.primaryCells.length === 1 && hint.solve) setHintEffect({ type: 'cell-glow', cell: hint.primaryCells[0] });
              startCooldown();
              setHintUsageCount(prev => prev + 1);
          } else {
              setHintButtonEffect('shake');
              setTimeout(() => setHintButtonEffect(null), 300);
          }
        }, [board, isHintOnCooldown, isGameWon, solution, activeHint, difficulty, placeNumberOnBoard, startCooldown]);
        const handleSetAutoNotes = (enabled) => {
          setIsAutoNotesEnabled(enabled);
          const newBoard = deepCopyBoard(board);
          for (let r=0; r<9; r++) for (let c=0; c<9; c++) {
            if (enabled && newBoard[r][c].value === 0 && newBoard[r][c].userNotes.size === 0) newBoard[r][c].autoNotes = calculateCandidates(newBoard, r, c);
            else newBoard[r][c].autoNotes.clear();
          }
          setHistory(prev => [...prev, board]);
          setRedoHistory([]);
          setBoard(newBoard);
        };
        const handleCloseSettings = (newDifficulty) => {
          setIsSettingsOpen(false);
          if (newDifficulty !== difficulty) {
            setDifficulty(newDifficulty);
            localStorage.setItem('sudoku-difficulty', newDifficulty);
            startNewGame(newDifficulty);
          }
        };
        const handleToggleNewGameConfirm = useCallback((e) => {
          if (e) e.stopPropagation();
          if (!isGameWon) { setShowNewGameConfirm(p => !p); }
        }, [isGameWon]);
        const handleShare = async () => {
          if (!initialPuzzle) return;
          const url = new URL(window.location.href);
          url.search = '';
          url.searchParams.set('puzzle', initialPuzzle);
          const statsString = `${elapsedTime}-${movesCount}-${mistakesCount}-${hintUsageCount}`;
          url.searchParams.set('stats', statsString);
          const shareData = { title: 'Sudoku Challenge', text: 'Think you can solve this Sudoku puzzle I just played?', url: url.toString(), };
          if (navigator.share) { try { await navigator.share(shareData); } catch (err) {} }
          else {
              try {
                  await navigator.clipboard.writeText(shareData.url);
                  setShareFeedback('Link Copied!');
                  setTimeout(() => setShareFeedback(''), 2000);
              } catch (err) {
                  console.error('Failed to copy link: ', err);
                  setShareFeedback('Failed to copy!');
                  setTimeout(() => setShareFeedback(''), 2000);
              }
          }
        };
        useEffect(() => {
          const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
          const updateMode = () => { if (colorMode === 'system') setIsDarkMode(mediaQuery.matches); else setIsDarkMode(colorMode === 'dark'); };
          updateMode();
          mediaQuery.addEventListener('change', updateMode);
          return () => mediaQuery.removeEventListener('change', updateMode);
        }, [colorMode]);
        useEffect(() => {
          const themeData = themes[theme]?.[isDarkMode ? 'dark' : 'light'] || themes.default[isDarkMode ? 'dark' : 'light'];
          for (const [key, value] of Object.entries(themeData)) { document.documentElement.style.setProperty(key, String(value)); }
          localStorage.setItem('sudoku-theme', theme);
          localStorage.setItem('sudoku-color-mode', colorMode);
          localStorage.setItem('sudoku-auto-notes', String(isAutoNotesEnabled));
          localStorage.setItem('sudoku-highlight-notes', String(isHighlightNotesEnabled));
          localStorage.setItem('sudoku-timer-visible', String(isTimerVisible));
          localStorage.setItem('sudoku-stats', JSON.stringify(stats));
        }, [theme, isDarkMode, colorMode, isAutoNotesEnabled, isHighlightNotesEnabled, isTimerVisible, stats]);
        useEffect(() => {
          const serialize = (k, v) => v instanceof Set ? { __dataType: 'Set', value: [...v] } : v;
          const deserialize = (k, v) => (v && typeof v === 'object' && v.__dataType === 'Set' && Array.isArray(v.value)) ? new Set(v.value) : v;
          const urlParams = new URLSearchParams(window.location.search);
          const puzzleString = urlParams.get('puzzle');
          const statsString = urlParams.get('stats');
          if (puzzleString || statsString) { window.history.replaceState({}, '', window.location.pathname); }
          if (statsString) {
            const [time, moves, mistakes, hints] = statsString.split('-').map(Number);
            if (![time, moves, mistakes, hints].some(isNaN)) {
              setSharerStats({ time, moves, mistakes, hints });
            }
          }
          const saved = localStorage.getItem('sudoku-saved-game');
          if (puzzleString) { startSharedGame(puzzleString); }
          else if (saved) {
              try {
                  const gameState = JSON.parse(saved, deserialize);
                  setBoard(gameState.board); setSolution(gameState.solution); setHistory(gameState.history || []); setRedoHistory(gameState.redoHistory || []); setElapsedTime(gameState.elapsedTime || 0); setMovesCount(gameState.movesCount || 0); setMistakesCount(gameState.mistakesCount || 0); setHintUsageCount(gameState.hintUsageCount || 0); if (gameState.difficulty) setDifficulty(gameState.difficulty);
                  const loadedPuzzleString = gameState.board.map(r => r.map(c => c.isInitial ? c.value : 0).join('')).join('');
                  setInitialPuzzle(loadedPuzzleString);
                  setIsTimerRunning(true);
              } catch(e) { startNewGame(difficulty); }
          } else { startNewGame(difficulty); }
        }, []);
        useEffect(() => { if (board.length > 0 && !isGameWon) { const serialize = (k, v) => v instanceof Set ? { __dataType: 'Set', value: [...v] } : v; localStorage.setItem('sudoku-saved-game', JSON.stringify({ board, solution, history, redoHistory, elapsedTime, movesCount, mistakesCount, difficulty, hintUsageCount }, serialize)); } }, [board, solution, history, redoHistory, elapsedTime, movesCount, mistakesCount, difficulty, hintUsageCount, isGameWon]);
        useEffect(() => { if (isGameWon) setAnimationState('playing'); }, [isGameWon]);
        useEffect(() => { let intervalId; if (isTimerRunning && !isUIBlocked && !isGameWon) { intervalId = setInterval(() => setElapsedTime(prev => prev + 1000), 1000); } return () => clearInterval(intervalId); }, [isTimerRunning, isUIBlocked, isGameWon]);
        useEffect(() => { const handleVisibilityChange = () => setIsTimerRunning(!document.hidden && !isUIBlocked && !isGameWon); document.addEventListener('visibilitychange', handleVisibilityChange); return () => document.removeEventListener('visibilitychange', handleVisibilityChange); }, [isUIBlocked, isGameWon]);
        useEffect(() => { if (selectedCell) { setHighlightedNumPad(null); } }, [selectedCell]);
        useEffect(() => {
          const handleKeyDown = (e) => {
            if (isGameWon || isUIBlocked) return;
            if (!selectedCell && e.key.startsWith('Arrow')) { setSelectedCell({ row: 0, col: 0 }); e.preventDefault(); return; }
            if (!selectedCell) return;
            const { row, col } = selectedCell;
            switch (e.key) {
              case 'ArrowUp': setSelectedCell({ row: Math.max(0, row - 1), col }); e.preventDefault(); break;
              case 'ArrowDown': setSelectedCell({ row: Math.min(8, row + 1), col }); e.preventDefault(); break;
              case 'ArrowLeft': setSelectedCell({ row, col: Math.max(0, col - 1) }); e.preventDefault(); break;
              case 'ArrowRight': setSelectedCell({ row, col: Math.min(8, col + 1) }); e.preventDefault(); break;
              case 'Backspace': case 'Delete': handleDelete(); e.preventDefault(); break;
              case 'Escape': setSelectedCell(null); setActiveHint(null); e.preventDefault(); break;
              default: if (!isNaN(e.key) && e.key >= 1 && e.key <= 9) handleNumberClick(Number(e.key)); break;
            }
          };
          window.addEventListener('keydown', handleKeyDown);
          return () => window.removeEventListener('keydown', handleKeyDown);
        }, [selectedCell, handleDelete, handleNumberClick, isGameWon, isUIBlocked]);
        if (board.length === 0 || solution.length === 0) { return <div className="flex items-center justify-center min-h-screen text-lg text-[var(--color-text-primary)]">Generating Puzzle...</div>; }
        const highlightedNumFromCell = selectedCell && board[selectedCell.row][selectedCell.col].value > 0 ? board[selectedCell.row][selectedCell.col].value : null;
        const highlightedNum = highlightedNumFromCell ?? highlightedNumPad;
        const hintDisplay = (<div className="relative w-full h-6 mb-2" onClick={(e) => e.stopPropagation()}><div className={`absolute inset-0 flex items-center justify-center transition-opacity duration-300 ${activeHint ? 'opacity-100' : 'opacity-0'}`}>{activeHint && (<button onClick={() => setTutorialHintType(activeHint.type)} className="px-4 py-1 rounded-full text-sm font-bold shadow-md bg-[var(--color-ui-bg-secondary)] text-[var(--color-hint-text)] hover:bg-[var(--color-ui-bg-hover)] transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-accent)] focus:ring-offset-[var(--color-page-bg)]" aria-label={`Learn about ${activeHint.type}`}>{activeHint.type}</button>)}</div></div>);
        return (
          <div className="min-h-screen font-sans relative" onClick={() => { setSelectedCell(null); setHighlightedNumPad(null); setShowNewGameConfirm(false); setActiveHint(null); }}>
            <Header onOpenSettings={() => setIsSettingsOpen(true)} onOpenStats={() => setIsStatsOpen(true)} onTitleClick={handleToggleNewGameConfirm} isNewGameConfirmOpen={showNewGameConfirm} />
            <div className={`min-h-screen flex flex-col items-center justify-start md:justify-center pt-16 pb-[calc(1rem+env(safe-area-inset-bottom))] px-4`}>
              <main className={`w-full max-w-lg flex flex-col items-center gap-2 transition-all duration-300 ${isUIBlocked ? 'blur-sm pointer-events-none' : ''} mt-8 md:mt-0`}>
                  {hintDisplay}
                  <div className="relative w-full" onClick={(e) => e.stopPropagation()}>{animationState !== 'idle' && <VictoryScreen message={victoryMessage} moves={movesCount} elapsedTime={elapsedTime} mistakes={mistakesCount} hints={hintUsageCount} sharerStats={sharerStats} />}<SudokuBoard board={board} solution={solution} selectedCell={selectedCell} onCellClick={(r, c) => { if (isGameWon) return; if (activeHint) setActiveHint(null); setSelectedCell(p => p?.row === r && p?.col === c ? null : {row: r, col: c})}} isNotesMode={isNotesMode} isDarkMode={isDarkMode} forceDarkMode={isGameWon} isAutoNotesEnabled={isAutoNotesEnabled} isHighlightNotesEnabled={isHighlightNotesEnabled} highlightedNumber={highlightedNum} activeHint={activeHint} hintEffect={hintEffect} /></div>
                  <div className="relative w-full flex flex-col items-center gap-0 mt-4">
                    <div className={`w-full transition-opacity duration-300 ease-in-out ${isGameWon ? 'opacity-0 pointer-events-none' : ''}`}><div className={`transition-transform duration-500 ease-in-out ${isGameWon ? 'translate-y-8' : ''}`} onClick={(e) => e.stopPropagation()}><NumberPad onNumberClick={handleNumPadAction} isNotesMode={isNotesMode} highlightedNumber={highlightedNumPad} /></div></div>
                    <div className="relative w-full flex justify-center" style={{minHeight: '80px'}}>
                      <div className={`absolute inset-0 flex items-center justify-center transition-all duration-500 ease-in-out transform ${isGameWon ? 'opacity-100 scale-100' : 'opacity-0 scale-95 pointer-events-none'}`} style={{transitionDelay: isGameWon ? '250ms' : '0ms'}} onClick={(e) => e.stopPropagation()}>
                        <div className="flex items-center gap-4">
                          <button onClick={() => startNewGame(difficulty)} className="bg-[var(--color-controls-bg)] text-[var(--color-controls-text)] font-bold py-4 px-12 rounded-full text-2xl hover:bg-[var(--color-controls-bg-hover)] transition-colors transform active:scale-95 shadow-lg"><span className={`transition-opacity duration-300 ease-in-out ${isGameWon ? 'opacity-100' : 'opacity-0'}`} style={{transitionDelay: isGameWon ? '400ms' : '0ms'}}>Play Again</span></button>
                          <div className="relative"><button onClick={handleShare} className="w-16 h-16 flex items-center justify-center bg-[var(--color-controls-bg)] text-[var(--color-controls-text)] rounded-full hover:bg-[var(--color-controls-bg-hover)] transition-colors transform active:scale-95 shadow-lg" aria-label="Share Game"><ShareIcon /></button><div className={`pointer-events-none absolute bottom-full mb-2 left-1/2 -translate-x-1/2 px-3 py-1 text-sm rounded-md bg-black/70 text-white transition-all duration-300 ${shareFeedback ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-2'}`}>{shareFeedback}</div></div>
                        </div>
                      </div>
                      <div className={`absolute inset-0 flex items-center justify-center transition-opacity duration-300 ${isGameWon ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}>
                          <div className="flex items-center gap-4" onClick={(e) => e.stopPropagation()}>
                              <div className={`relative rounded-full p-2 shadow-lg transition-colors duration-300 bg-[var(--color-controls-bg)]`}>
                                  <div className={`transition-all duration-200 ease-out ${showNewGameConfirm ? 'opacity-0 blur-sm scale-90' : 'opacity-100 blur-0 scale-100'}`}><Controls isNotesMode={isNotesMode} onToggleNotesMode={() => setIsNotesMode(p => !p)} onUndo={() => {if(history.length>0){setRedoHistory(p=>[...p,board]); setBoard(history[history.length-1]); setHistory(history.slice(0,-1)); setActiveHint(null);}}} canUndo={history.length>0} onRedo={() => {if(redoHistory.length>0){setHistory(p=>[...p,board]); setBoard(redoHistory[redoHistory.length-1]); setRedoHistory(redoHistory.slice(0,-1)); setActiveHint(null);}}} canRedo={redoHistory.length > 0} onHint={handleHint} isHintOnCooldown={isHintOnCooldown} cooldownDuration={4} onDelete={handleDelete} hintButtonEffect={hintButtonEffect}/></div>
                                  <div className={`absolute inset-0 flex items-center justify-center transition-opacity duration-300 ease-in ${showNewGameConfirm ? 'opacity-100' : 'opacity-0 pointer-events-none'}`} style={{transitionDelay: showNewGameConfirm ? '200ms' : '0ms'}}><button onClick={() => { startNewGame(difficulty); setShowNewGameConfirm(false); }} className="w-full h-full text-[var(--color-controls-text)] font-bold text-2xl">New Game</button></div>
                              </div>
                              {isTimerVisible && !isGameWon && (<div className={`h-12 flex items-center justify-center px-4 rounded-full text-lg font-semibold tabular-nums tracking-wider transition-colors bg-[var(--color-timer-bg)] text-[var(--color-timer-text)]`}>{formatTime(elapsedTime)}</div>)}
                          </div>
                      </div>
                    </div>
                  </div>
              </main>
            </div>
            <SettingsPanel isOpen={isSettingsOpen} onClose={handleCloseSettings} currentDifficulty={difficulty} theme={theme} setTheme={setTheme} colorMode={colorMode} setColorMode={setColorMode} onFillBoard={() => { setIsSettingsOpen(false); setTimeout(() => { const solved = solution.map(r => r.map(v => ({value: v, isInitial: false, isWrong: false, userNotes: new Set(), autoNotes: new Set(), eliminatedNotes: new Set()}))); setBoard(solved); triggerWinState(); }, 300); }} isAutoNotesEnabled={isAutoNotesEnabled} onSetAutoNotes={handleSetAutoNotes} isHighlightNotesEnabled={isHighlightNotesEnabled} onSetHighlightNotes={setIsHighlightNotesEnabled} isTimerVisible={isTimerVisible} onSetIsTimerVisible={setIsTimerVisible} />
            <StatsPanel isOpen={isStatsOpen} onClose={() => setIsStatsOpen(false)} stats={stats} />
            <HintTutorial hintType={tutorialHintType} onClose={() => setTutorialHintType(null)} />
          </div>
        );
      }
      
      // --- index.tsx (entry point) ---
      
      const rootElement = document.getElementById('root');
      if (rootElement) {
          const root = ReactDOM.createRoot(rootElement);
          root.render(
              <StrictMode>
                  <App />
              </StrictMode>
          );
      } else {
          console.error('Fatal: Root element not found.');
      }
    </script>
    <script>
      // Service workers cannot be registered when running from the `file://` protocol.
      // This code is commented out to prevent errors in the console.
      /*
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js')
            .then(reg => console.log('SW registered.', reg))
            .catch(err => console.error('SW registration failed:', err));
        });
      }
      */
    </script>
  </body>
</html>